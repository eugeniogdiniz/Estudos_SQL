-- AULA LINGUAGEM SQL SERVER
-- PROF. FABIANO PASSOS

-- COMENTÁRIO EM LINHA: LINHA IGNORADA PELO COMPILADOR
-- HOT KEY: CTRL + R
-- SQL SERVER NÃO É CASE SENSITIVE E NÃO É ORIENTADO A COLUNAS (COLUNAMENTO)

-- MEU PRIMEIRO COMANDO SQL:
select getdate()

SELECT GETDATE()

Select GetDate()

/* --------------------------------------------------------------------
COMENTA TUDO QUE ENCONTRAR, ATÉ QUE EXISTA UMA SEQUENCIA PARA FECHAMENTO
ESTA SEQUENCIA É O */

/* ------------------------------------------------------------------------
|	V.1.1	-	PROGRAMA DE AULAS EM LINGUAGEM SQL	-	CR.DATE: 10/08/21 |
|   V.1.1. OBJETIVO: CALCULAR O IR DO FUNCIONÁRIO - DATA: DD/MM/AAAA      |
|   V.1.4. OBJETIVO: ...												  |
-------------------------------------------------------------------------*/

-- CRIANDO O MEU DATABASE
Create Database AULA_BD2AN

-- APAGA O DATABASE
DROP DATABASE AULA_BD2AN

-- COLOCAR O DATABASE EM USO
USE AULA_BD2AN

-- PROFESSOR: CRIAR TABELA DE ALUNOS
CREATE TABLE TB_ALUNO
(	
	CPF				INT			,		-- TIPO: INTEIRO
	NOME			CHAR(20)			-- TIPO: CARACTERE COM 20 POSIÇÕES
)

INSERT TB_ALUNO
( CPF , NOME )
VALUES
( 100 , 'FABIANO'),			-- CAMPOS DE TEXTO FICAM SEMPRE ENTRE ASPAS SIMPLES
( 200 , 'ROMEU'),
( 300 , 'HENRY'),
( 400 , 'PASSOS')

-- ESTOURANDO O CAMPO CPF (INT)
INSERT TB_ALUNO
( CPF , NOME )
VALUES
( -2147483649 , 'ISABELLA')

SELECT * FROM TB_ALUNO

DROP TABLE	TB_ALUNO

-- EXERCICIO: CRIAR E POPULAR A TABELA DE NOTAS, CONTENDO OS SEGUINTES CAMPOS
-- ID			-	TIPO: INTEIRO
-- CPF_ALUNO	-	TIPO: INTEIRO
-- NOTA			-	TIPO: INTEIRO
CREATE TABLE TB_NOTA
(
	ID				INT				,
	CPF_ALUNO		INT				,
	NOTA			INT
)

INSERT TB_NOTA
( ID , CPF_ALUNO , NOTA )
VALUES
( 99 , 100 , 10 ),
( 99 , 200 , 09 ),
( 98 , 300 , 05 ),
( 97 , 400 , 06 ),
( 96 , 400 , 07 )

SELECT * FROM TB_NOTA

-- OBSERVAÇÃO: COMO FAÇO PARA NÃO ESTOURAR OS DADOS DE CPF?

-- EXPLICANDO O COMANDO GO: ENCERRADOR DE LOTES DE PROCESSAMENTO
CREATE DATABASE TESTE_GO
GO

USE TESTE_GO
GO

CREATE TABLE TESTE_GO ( TESTE_CAMPO INT )
GO

USE MASTER
DROP DATABASE TESTE_GO

-----------------------------------
-- INTERVALO: RETORNAMOS AS 21:20H
-----------------------------------

-- EXERCICIO:
-- 1. CRIAR E POPULAR TABELA UTILIZANDO QUATRO DIFERENTES TIPOS DE DADOS NUMÉRICOS 
-- DICA: EM SQL, DECIMAL POINT IS POINT (R$ 10.50) 
--       EM PORTUGUÊS, DECIMAL POINT IS COMMA (R$ 10,50)
CREATE TABLE TB_TIPOS
(
		NOTA_ALUNO			DECIMAL(9,2)      -- EXEMPLO: 9999999.99  
	,	NOTA_TUTOR			DECIMAL(9,4)	  -- EXEMPLO: 99999.9999
	,	SALARIO				MONEY			  -- EXPLORAR O MONEY
	,	CPF					BIGINT			  -- BIGINT PARA CPF
	,	NOTA_SEM_PARAM		DECIMAL
)

INSERT TB_TIPOS
( NOTA_ALUNO, NOTA_TUTOR, SALARIO, CPF, NOTA_SEM_PARAM )
VALUES
( 10.10, 99999.1234, 15000.50, 31790699901, 100.99 )

SELECT * FROM TB_TIPOS

SP_HELP TB_TIPOS

-- APÓS AULA DE TIPOS DE DADOS, VAMOS TESTAR A TABELA DE TIPOS

DROP TABLE TB_TIPOS

CREATE TABLE TB_TIPOS
(
		NOTA_ALUNO			DECIMAL(9,2)      -- EXEMPLO: 9999999.99
	,	COD_ALUNO			INT			
	,	NOME				CHAR(26)
	,	DATA_NASC			DATETIME
	,	CONTAGEM_HEMACIAS	FLOAT(50)
	,	OBSERVACOES			VARCHAR(4000)
)

INSERT TB_TIPOS
( NOTA_ALUNO	, COD_ALUNO		, NOME							, DATA_NASC						, CONTAGEM_HEMACIAS	)
VALUES
( 10.00			, 2147483647	, 'FABIANO ROMEU HENRY PASSOS'  , '1984-02-12 12:55:59:011'		, 20.1234567890	)

SELECT * FROM TB_TIPOS

-- EXERCICIO DE PRESENÇA
-- Entregar o Código SQL referente aos Exercícios abaixo:

-- Exercícios: 
--a. Criar Banco de Dados de Empresa
--b. Colocar Banco de Dados em Uso
--c. Criar Tabelas de:
--1. Funcionário (CPF, Nome, Salário, Data de Nascimento)
--2. Dependentes (CPF, CPF do Responsável, Nome, Data de Nascimento)
--d. Inserir Registros em ambas
-- Obs.: Utilize a maior variedade de Tipos de Dados possível.

--a. Criar Banco de Dados de Notas Fiscais
--b. Colocar Banco de Dados em Uso
--c. Criar Tabelas de:
--1. Pedidos (ID do Pedido, ID do Item, Valor Total, Descrição, Data do Pedido)
--2. Itens do Pedido (ID do Item, Descrição, Valor Unitário, Quantidade)
--d. Inserir Registros em ambas
-- Obs.: Utilize a maior variedade de Tipos de Dados possível

-- CONSTRAINTS (TRADUÇÃO LITERAL: RESTRIÇÕES, TRADUÇÃO DA AULA: CONFIGURAÇÃO)
-- NOT NULL / NULL (*NÃO É UMA CONSTRAINT): INFORMA SE O CAMPO PODE OU NÃO RECEBER VALORES NULOS
--                                          OU SEJA, NÃO RECEBER INFORMAÇÃO NENHUMA
-- O QUE É O "NULL"? ELE É AUSÊNCIA DE INFORMAÇÃO

-- IDENTITY: CRIA UM CAMPO DE AUTO NUMERAÇÃO (NÃO PRECISO PREENCHER)
-- IDENTITY(SEED,INCREMENT)



-- PRIMARY KEY - RESPOSTAS ALUNOS:
-- CHAVE PARA IDENTIFICAÇÃO, IDENTIFICA "CADA PESSOA", OU SEJA, É ÚNICO, POR EXEMPLO O CPF

-- PRIMARY KEY: ELA POSSUI TRÊS PROPRIEDADES
-- 1. NÃO ACEITA VALORES DUPLICADOS (OK)
-- 2. ELA AUMENTA A PERFORMANCE DE UTILIZAÇÃO DA TABELA (ATRAVÉS DESTE CAMPO) (OK)
-- 3. ABRE UMA PORTA PARA UM RELACIONAMENTO (OK). PORQUE SÓ É POSSÍVEL CONECTAR UMA FK EM UMA PK

-- SINTAXE PK: CONSTRAINT <NOME_DA_PK> PRIMARY KEY (CAMPO_PK) [APÓS A DEFINIÇÃO DE CAMPOS]
-- SINTAXE PK (RESUMIDA): INSERIR A EXPRESSÃO PRIMARY KEY APÓS A DEFINIÇÃO DO CAMPO

-- FOREIGN KEY: CRIA UMA RELAÇÃO DE DEPENDÊNCIA COM OUTRA TABELA. ELA CRIA O RELACIONAMENTO!
--              ESTA RELAÇÃO É HIERARQUICA, OU SEJA, MÃE E FILHA, PAI E FILHO
-- SINTAXE FK: CONSTRAINT <NOME_DA_FK> FOREIGN KEY (CAMPO_FK) REFERENCES TABELA_MAE(CAMPO_MAE) [APÓS A DEFINIÇÃO DE CAMPOS]
-- SINTAXE FK (RESUMIDA): INSERIR A EXPRESSÃO FOREIGN KEY + REFERENCES APÓS A DEFINIÇÃO DO CAMPO

-- UNIQUE KEY

CREATE TABLE <nome da tabela>
( 
		<nome coluna 1> <tipo da coluna> (<tamanho da coluna>) [NOT NULL]
	,	<nome coluna 2> <tipo da coluna> (<tamanho da coluna>) [NOT NULL]
	,	...
);

-- Simple CREATE TABLE Syntax (common if not using options)
-- {}:		LISTA DE OPÇÕES DE PREENCHIMENTO OBRIGATÓRIO
-- SCHEMA:	A FORMA COMO MEU USUÁRIO É VISTO PELO SGBD (SISTEMA GERENCIADOR DE BANCO DE DADOS)
--          DBO: DATA BASE OWNER (ADMINISTRADOR DA MÁQUINA E DO BANCO)
--          DBU: DATA BASE USER  (CONFIGURAÇÃO DE VISUALIZAR, MAS NAO DROPAR, POR EXEMPLO)
--          DBA: DATA BASE ADMINISTRATOR
-- NA IMPACTA SCHEMA É O RA

-- REGRA DE NOMECLATURA: NÃO POSSO CRIAR CAMPOS QUE COMECEM COM...
--							A. NÚMEROS
--							B. CARACTERES ESPECIAIS
--							C. QUE CONTENHAM ESPAÇO EM SEU NOME
-- PORÉM, VARIA... 

CREATE TABLE
    { database_name.schema_name.table_name | schema_name.table_name | table_name }
    ( { <column_definition> } [ ,...n ] )
[ ; ]


USE MASTER
CREATE TABLE DB_EMPRESA.DBO.TESTE ( CAMPO1 INT )

USE DB_EMPRESA
SELECT * FROM TESTE
DROP TABLE TESTE


--a. Criar Banco de Dados de Empresa
CREATE DATABASE DB_EMPRESA

--b. Colocar Banco de Dados em Uso
USE DB_EMPRESA

--c. Criar Tabelas de:
--1. Funcionário (CPF, Nome, Salário, Data de Nascimento)
DROP TABLE TB_FUNC

-- COM SINTAXE COMPLETA DA PK
CREATE TABLE TB_FUNC
(
	ID_FUNC			INT			IDENTITY(10,5)	,		-- CAMPO DE AUTO NUMERAÇÃO
	CPF				BIGINT						,		-- NÃO ACEITA VALORES NULOS
	NOME			VARCHAR(50)	NOT NULL		,		-- NÃO ACEITA VALORES NULOS
	SALARIO			MONEY						,
	DATA_NASC		DATE						-- RECOMMENDED ENTRY FORMAT: 'YYYY-MM-DD'

	CONSTRAINT PK_TB_FUNC_CPF	PRIMARY KEY (CPF)	
)

-- COM SINTAXE RESUMIDA DA PK
CREATE TABLE TB_FUNC
(
	ID_FUNC			INT			IDENTITY(10,5)	,		-- CAMPO DE AUTO NUMERAÇÃO
	CPF				BIGINT		PRIMARY KEY		,		-- NÃO ACEITA VALORES NULOS
	NOME			VARCHAR(50)	NOT NULL		,		-- NÃO ACEITA VALORES NULOS
	SALARIO			MONEY						,
	DATA_NASC		DATE						-- RECOMMENDED ENTRY FORMAT: 'YYYY-MM-DD'
)

INSERT TB_FUNC
( CPF , NOME , SALARIO , DATA_NASC )
VALUES
( 101 , 'ANA',    1000 , '2000-01-01' )

INSERT TB_FUNC
( CPF , NOME , SALARIO )
VALUES
( 102 , 'BIA',  NULL )

INSERT TB_FUNC
( CPF , NOME , SALARIO )
VALUES
( 105 , 'FABIANO',  2000 )

SELECT * FROM TB_FUNC

-- SP_HELP: STORED PROCEDURE DE SISTEMA (PROCEDIMENTO ARMAZENADO)
--          AO INFORMAR O NOME DE UMA TABELA, ELE RETORNA TODAS AS CONFIGURAÇÕES DESTA.
SP_HELP TB_FUNC

-- HOT KEY PARA SP_HELP: ALT + F1 (SELECIONANDO A TABELA)
TB_FUNC

-- EXERCÍCIO: NA TABELA DE DEPENDENTES, CRIAR AS SEGUINTES CONFIGURAÇÕES
-- CPF, CPF DO RESPONSÁVEL E NOME NÃO ACEITAM NULOS
-- CRIAR UM CAMPO (ID_DEPENDENTE) DE AUTO NUMERAÇÃO QUE INICIE COM 1000 E INCREMENTE DE 2 EM 2
--2. Dependentes (CPF, CPF do Responsável, Nome, Data de Nascimento)
-- OBS.: TESTEM OS INSERTS
DROP TABLE TB_DEPN

-- COM SINTAXE COMPLETA DA FK
CREATE TABLE TB_DEPN
(
	ID_DEPENDENTE			INT		IDENTITY(1000,2),	
	CPF						BIGINT		NOT NULL	,
	CPF_RESP				BIGINT		NOT NULL	,
	NOME					VARCHAR(50)	NOT NULL	,
	DATA_NASC				DATE

	CONSTRAINT PK_TB_DEPN_CPF		PRIMARY KEY (CPF),
	CONSTRAINT FK_TB_DEPN_CPF_RESP	FOREIGN KEY (CPF_RESP) REFERENCES TB_FUNC(CPF)
)

-- COM SINTAXE RESUMIDA DA FK
CREATE TABLE TB_DEPN
(
	ID_DEPENDENTE			INT		IDENTITY(1000,2)									,	
	CPF						BIGINT		NOT NULL										,
	CPF_RESP				BIGINT		NOT NULL	FOREIGN KEY REFERENCES TB_FUNC(CPF)	,
	NOME					VARCHAR(50)	NOT NULL										,
	DATA_NASC				DATE
)

INSERT TB_DEPN
( CPF , CPF_RESP , NOME , DATA_NASC )
VALUES
( 1001, 101, 'ISABELLA', '2014-03-01' )

INSERT TB_DEPN
( CPF , CPF_RESP , NOME )
VALUES
( 1002, 101, 'MANUELA')

INSERT TB_DEPN
( CPF , CPF_RESP , NOME )
VALUES
( 1003, 105, 'MARIA')


SELECT * FROM TB_FUNC
SELECT * FROM TB_DEPN


--d. Inserir Registros em ambas


-- Obs.: Utilize a maior variedade de Tipos de Dados possível.

-- EXERCICIO: CRIAR UMA TABELA DE PRODUTOS (COD, NOME) E UMA TABELA DE FORNECEDORES (COD, NOME, COD_PRODUTO)
-- CRIEM A RELAÇÃO ENTRE PK E FK
CREATE TABLE TB_PROD
(
		COD			INT			
	,	NOME		VARCHAR(20)

	CONSTRAINT	PK_TB_PROD_COD				PRIMARY KEY	(COD)
)

INSERT TB_PROD
( COD , NOME )
VALUES
( 9001 , 'LIQUIDIFICADOR' ),
( 9002 , 'TELEVISÃO' )

INSERT TB_PROD
( COD , NOME )
VALUES
( 9003 , 'CELULAR' )

CREATE TABLE TB_FORN
(	
		COD			INT
	,	NOME		VARCHAR(20)
	,	COD_PROD	INT

	CONSTRAINT	FK_TB_FORN_COD_PROD			FOREIGN KEY (COD_PROD)		REFERENCES TB_PROD(COD)
)

INSERT TB_FORN
( COD , NOME, COD_PROD )
VALUES
( 10001, 'SONY' , 9002 ),
( 10002, 'ARNO' , 9001 )

INSERT TB_FORN
( COD , NOME, COD_PROD )
VALUES
( 10003, 'SONY' , 9003 )

-- EXERCICIO: CRIAR AS SEGUINTES ESTRUTURAS
-- EMPREGADO (COD_FUNC, NOME, SALARIO, COD_DEPARTAMENTO)  --> EMPREGADO SEM DEPARTAMENTO NÃO TEM (FK)
-- DEPARTAMENTO (COD, NOME_DEPARTAMENTO, SALARIO_INIC)	  --> DEPARTAMENTO SEM EMPREGADO POSSO TER

-- DICA: DESENHEM ANTES PARA INDENTIFICAR QUEM É PK E QUEM É FK
CREATE TABLE TB_DEPARTAMENTO
(
	COD						INT				,
	NOME_DEPARTAMENTO		VARCHAR(50)		,
	SALARIO_INIC			MONEY

	CONSTRAINT	PK_TB_DEPARTAMENTO_COD			PRIMARY KEY (COD)
)

CREATE TABLE TB_EMPREGADO
(
	COD_FUN					INT				,
	NOME					VARCHAR(50)		,
	SALARIO					MONEY			,
	COD_DEPARTAMENTO		INT			

	CONSTRAINT	PK_TB_EMPREGADO_COD_FUN			 PRIMARY KEY (COD_FUN),
	CONSTRAINT	FK_TB_EMPREGADO_COD_DEPARTAMENTO FOREIGN KEY (COD_DEPARTAMENTO)	REFERENCES TB_DEPARTAMENTO(COD)
)

-- CORREÇÃO DA ATIVIDADE DE PRESENÇA (FECHAMENTO DE CONCEITOS DATA DEFINITION LANGUAGE - DDL)
CREATE DATABASE CONCESSIONARIA

USE CONCESSIONARIA

CREATE TABLE TB_ANO
(
	IDANO			SMALLINT			IDENTITY,
	ANO				SMALLINT			NOT NULL

	CONSTRAINT	PK_TB_ANO_IDANO			PRIMARY KEY (IDANO)
)

INSERT TB_ANO
( ANO )
VALUES
( 2021 ), ( 2020 ), ( 2019 ), ( 2018 )

CREATE TABLE TB_MES
(
	IDMES			SMALLINT			IDENTITY(15,3),
	MES				SMALLINT			NOT NULL

	CONSTRAINT	PK_TB_MES_IDMES			PRIMARY KEY (IDMES)
)

INSERT TB_MES
( MES )
VALUES
(01),(02),(03),(04),(05),(06),(07),(08),(09),(10),(11),(12) 

CREATE TABLE TB_MODELO
(
	IDMODELO		SMALLINT			IDENTITY,
	DESCRICAO		VARCHAR(50)			NOT NULL

	CONSTRAINT	PK_TB_MODELO_IDMODELO	PRIMARY KEY (IDMODELO)
)

INSERT TB_MODELO
( DESCRICAO )
VALUES
( 'VIRTUS' ), ( 'TORO' ), ( 'RENEGADE' ), ( 'A3' )

CREATE TABLE TB_FABRICANTE
(
	IDFABRICANTE	SMALLINT			IDENTITY,
	NOME			VARCHAR(50)			NOT NULL,		
	CIDADE			VARCHAR(50)			NOT NULL,
	ENDERECO		VARCHAR(100)				,
	UF				CHAR(02)					,
	TELEFONE		VARCHAR(20)					,
	CONTATO			VARCHAR(50)			NOT NULL

	CONSTRAINT	PK_TB_FABRICANTE_IDFABRICANTE	PRIMARY KEY (IDFABRICANTE)
)

INSERT TB_FABRICANTE
( NOME , CIDADE , ENDERECO , UF , TELEFONE , CONTATO )
VALUES
( 'VOLKSWAGEN', 'SBC', 'ROD. ANCHIETA S/N', 'SP', '9999-0001' , 'VOLKS@VOLKS.COM' )

INSERT TB_FABRICANTE
( NOME , CIDADE , CONTATO )
VALUES
( 'AUDI', 'SANTO ANDRÉ', 'AUDI@AUDI.COM' ),
( 'JEEP', 'SÃO CAETANO', 'JEEP@JEEP.COM' )

CREATE TABLE TB_VEICULO
(
	IDVEICULO			SMALLINT		IDENTITY,
	DESCRICAO			VARCHAR(50)		NOT NULL,
	VALOR				DECIMAL(8,2)	NOT NULL,	-- DECIMAL(8,2): 999999.99 | OPÇÃO: MONEY/SMALLMONEY
	IDMODELO			SMALLINT		NOT NULL,	
	IDFABRICANTE		SMALLINT		NOT NULL,
	IDANOFABRICACAO		SMALLINT		NOT NULL,
	DATACOMPRA			DATE			NOT NULL

	CONSTRAINT	PK_TB_VEIC_IDVEICULO	   PRIMARY KEY (IDVEICULO),
	CONSTRAINT	FK_TB_VEIC_IDMODELO	       FOREIGN KEY (IDMODELO)	     REFERENCES TB_MODELO(IDMODELO),
	CONSTRAINT	FK_TB_VEIC_IDFABRICANTE    FOREIGN KEY (IDFABRICANTE)    REFERENCES TB_FABRICANTE(IDFABRICANTE),
	CONSTRAINT  FK_TB_VEIC_IDANOFABRICACAO FOREIGN KEY (IDANOFABRICACAO) REFERENCES TB_ANO(IDANO)
)

INSERT TB_VEICULO
( DESCRICAO , VALOR, IDMODELO , IDFABRICANTE , IDANOFABRICACAO , DATACOMPRA )
VALUES
( 'AUDI A3' , 120999.50 , 4, 1 , 4 , '2021-03-22' )

CREATE TABLE TB_VENDAS_ANUAIS
(
	IDVENDAS			SMALLINT			IDENTITY,
	QTD					SMALLINT			NOT NULL,
	IDVEICULO			SMALLINT			NOT NULL,
	IDANODAVENDA		SMALLINT			NOT NULL,
	IDMESDAVENDA		SMALLINT			NOT NULL

	CONSTRAINT	PK_TB_VENDAS_IDVENDAS		PRIMARY KEY (IDVENDAS),
	CONSTRAINT	FK_TB_VENDAS_IDVEICULO		FOREIGN KEY (IDVEICULO)    REFERENCES TB_VEICULO(IDVEICULO),
	CONSTRAINT	FK_TB_VENDAS_IDANODAVENDA	FOREIGN KEY (IDANODAVENDA) REFERENCES TB_ANO(IDANO),
	CONSTRAINT	FK_TB_VENDAS_IDMESDAVENDA	FOREIGN KEY (IDMESDAVENDA) REFERENCES TB_MES(IDMES)
)

INSERT TB_VENDAS_ANUAIS
( QTD , IDVEICULO, IDANODAVENDA, IDMESDAVENDA )
VALUES
( 5000, 1 , 1, 15)

SELECT * FROM TB_ANO
SELECT * FROM TB_MES
SELECT * FROM TB_MODELO
SELECT * FROM TB_FABRICANTE
SELECT * FROM TB_VEICULO
SELECT * FROM TB_VENDAS_ANUAIS

-- CONSTRAINTS (DEFAULT E CHECK)

-- DEFAULT: PREENCHE UM DADO/INFORMAÇÃO, QUANDO SUPRIMIDO DO INSERT
-- SINTAXE: {COLUMN_DEFINITION} DEFAULT <VALOR_DEFAULT> 
DROP TABLE TB_CADASTRO

CREATE TABLE TB_CADASTRO
(
	IDCLIENTE			INT			IDENTITY							,
	NOME				VARCHAR(22)	DEFAULT 'CLIENTE NÃO PREENCHIDO'	,
	SALARIO				MONEY
)

INSERT TB_CADASTRO ( NOME , SALARIO ) VALUES ('FABIANO',1000)
INSERT TB_CADASTRO ( SALARIO ) VALUES ( 1000 ) 

SELECT * FROM TB_CADASTRO

-- EXERCICIO: CRIAR TABELA DE CLIENTES, COM IDCLIENTE (IDENTITY), NOME, CNPJ (NN), ENDERECO
-- QUANDO NÃO PREENCHIDAS AS INFORMAÇÕES DE NOME E/OU ENDERECO, INSERIR UMA INFORMAÇÃO DEFAULT
CREATE TABLE TB_CLIENTE
(
	IDCLIENTE				INT					IDENTITY									,
	NOME					VARCHAR(100)		DEFAULT 'NOME NÃO FORNECIDO PELO CLIENTE'	,
	CNPJ					BIGINT				NOT NULL									,
	ENDERECO				VARCHAR(100)		DEFAULT 'ENDEREÇO NÃO INFORMADO!!!'
)

INSERT TB_CLIENTE ( NOME , CNPJ , ENDERECO ) VALUES ( 'VOLKSWAGEN', 999888777666, 'ROD. ANCHIETA' )
INSERT TB_CLIENTE ( CNPJ , ENDERECO ) VALUES ( 999888777555, 'ROD. ANCHIETA' )
INSERT TB_CLIENTE ( NOME , CNPJ ) VALUES ( 'VOLKSWAGEN', 999888777444 )
INSERT TB_CLIENTE ( CNPJ ) VALUES ( 999888777333 )

SELECT * FROM TB_CLIENTE

-- CHECK:    VALIDA UMA CONDIÇÃO ANTES DE REALIZAR O INSERT
-- SINTAXE1: {COLUMN DEFINITION} CHECK (CONDIÇÃO)
-- SINTAXE2: CONSTRAINT <NOME_DA_CHECK> CHECK (CAMPO + CONDIÇÃO)

-- NECESSIDADE: NÃO PERMITIR QUE CADASTRE UMA QUANTIDADE MAIOR DO QUE 5000 NA TABELA DE VENDAS

CREATE TABLE TB_VENDAS
(
		PRODUTO				VARCHAR(100)			
	,	QUANTIDADE			INT				CHECK (QUANTIDADE < 5001)
)

INSERT TB_VENDAS ( PRODUTO , QUANTIDADE ) VALUES ( 'ASPIRADOR DE PÓ' , 5010 ) 
SELECT * FROM TB_VENDAS

-- EXERCICIO: APROVEITANDO A TABELA DE CLIENTES QUE FOI CRIADA ACIMA, INSIRA UM CAMPO COM 
--            A DATA DE NASCIMENTO E NÃO PERMITA QUE SE CADASTRE MENORES DE IDADE
DROP TABLE CLIENTES

CREATE TABLE CLIENTES
(
	IDCLIENTE		INT						IDENTITY,
	NOME			VARCHAR(30)				DEFAULT 'CLIENTE NÃO PREENCHIDO',
	CNPJ			BIGINT					NOT NULL                        ,
	ENDERECO		VARCHAR(100)			DEFAULT 'CLIENTE NÃO PREENCHIDO',
	DATANASCIMENTO	DATE					CHECK (DATANASCIMENTO < '2003-09-01')
)

INSERT CLIENTES ( CNPJ, DATANASCIMENTO ) VALUES ( 999111 , '1984-02-12' )
INSERT CLIENTES ( CNPJ, DATANASCIMENTO ) VALUES ( 76864962000150 , '1984-02-12' )
INSERT CLIENTES ( CNPJ, DATANASCIMENTO ) VALUES ( 76864962000151 , '2014-02-12' )

SELECT * FROM CLIENTES

SP_HELP CLIENTES

-- CRIANDO UMA CONSTRAINT CHECK COM A SINTAXE COMPLETA (SINTAXE2)
-- CHECK:    VALIDA UMA CONDIÇÃO ANTES DE REALIZAR O INSERT
-- SINTAXE2: CONSTRAINT <NOME_DA_CHECK> CHECK (CAMPO + CONDIÇÃO)
-- QUANDO O COMANDO CHECK ESTÁ REFERENCIANDO UMA COLUNA QUE NÃO É A ÚLTIMA DA TABELA, EM SUA SINTAXE COMPLETA,
-- É NECESSÁRIO SEPARAR O ÚLTIMO CAMPO, DAS CONTRAINTS, COM UMA VÍRGULA

DROP TABLE TB_VENDAS

CREATE TABLE TB_VENDAS
(
		ID_PRODUTO			INT					IDENTITY					,
		QUANTIDADE			INT												,
		PRODUTO				VARCHAR(100)		DEFAULT 'NÃO INFORMADO'		,		

	CONSTRAINT	CK_TB_VENDAS_QUANTIDADE		CHECK (QUANTIDADE < 5001)
)

INSERT TB_VENDAS ( QUANTIDADE ) VALUES (6000)

-- AC01: APRESENTAÇÃO + PRAZO + LIBERAÇÃO (INDIVIDUAL)

-- AC01: CORREÇÃO DO ÚLTIMO EXERCÍCIO ENVOLVENDO DDL (DATA DEFINITION LANGUAGE)

-- INÍCIO DA CORREÇÃO: 19:30H
-- FIM	  DA CORREÇÃO: 20:05H
-- TEMPO TOTAL:		   35 MINUTOS...

CREATE DATABASE RH

USE RH

CREATE TABLE TB_DEPARTAMENTO
(
	COD_DEPTO			INT				IDENTITY,
	DEPTO				VARCHAR(30)		NOT NULL

	CONSTRAINT	PK_TB_DEPTO_COD_DEPTO	PRIMARY KEY (COD_DEPTO)
)

INSERT TB_DEPARTAMENTO
( DEPTO )
VALUES
('FINANCEIRO'),
('TECNOLOGIA'),
('JURIDICO'),
('VENDAS'),
('RH')


CREATE TABLE TB_CARGO
(
	COD_CARGO			INT				IDENTITY,
	CARGO				VARCHAR(30)		NOT NULL,
	SALARIO_INIC		MONEY			NOT NULL	

	CONSTRAINT	PK_TB_CARGO_COD_CARGO	PRIMARY KEY (COD_CARGO)
)

INSERT TB_CARGO
( CARGO , SALARIO_INIC )
VALUES
( 'ANALISTA FISCAL JR.' , 2500.99 ),
( 'DBA'					, 5000.10 ),
( 'ADVOGADO PL.'		, 4000.50 ),
( 'VENDEDOR'			, 3000.75 ),
( 'RECRUTADOR'			, 2500.10 )

CREATE TABLE TB_EMPREGADO
(
	CODFUN				INT			IDENTITY,
	NOME				VARCHAR(50)	NOT NULL,
	NUM_DEPEND			INT			NOT NULL, -- QTDE DE DEPENDENTES CADASTRADOS PARA ESTE FUNC.
	DATA_NASCIMENTO		DATE		NOT NULL,
	COD_DEPTO			INT			NOT NULL,
	COD_CARGO			INT			NOT NULL,
	DATA_ADMISSAO		DATE		NOT NULL,
	SALARIO				MONEY		NOT NULL,
	PREMIO_MENSAL		MONEY		NOT NULL,
	SINDICALIZADO		CHAR(01)	NOT NULL, -- S: SINDICALIZADO, N: NÃO SINDICALIZADO
	OBS					VARCHAR(100)		,
	FOTO				IMAGE				, -- VARBINARY(MAX) TAMBÉM FUNCIONA PARA FOTOS
	COD_SUPERVISOR		INT					

	CONSTRAINT	PK_TB_EMP_CODFUN	PRIMARY KEY (CODFUN),
	CONSTRAINT	FK_TB_EMP_COD_DEPTO	FOREIGN KEY (COD_DEPTO)	REFERENCES TB_DEPARTAMENTO(COD_DEPTO),
	CONSTRAINT	FK_TB_EMP_COD_CARGO	FOREIGN KEY (COD_CARGO)	REFERENCES TB_CARGO(COD_CARGO)
)

-- EXEMPLO DE FERRAMENTA DE ARMAZENAMENTO DE IMAGENS: CONTENT MANAGER (IBM)

INSERT TB_EMPREGADO
( NOME , NUM_DEPEND , DATA_NASCIMENTO, COD_DEPTO, COD_CARGO, DATA_ADMISSAO,
  SALARIO, PREMIO_MENSAL, SINDICALIZADO	)
VALUES
( 'FABIANO' , 1 , '1984-02-12' , 1 , 1 , '2007-07-20', 1000 , 10000 , 'S' ),
( 'EDUARDO' , 1 , '1985-03-13' , 2 , 2 , '2007-07-20', 2000 , 11000 , 'N' ),
( 'ISABELLA', 1 , '1986-04-14' , 3 , 3 , '2007-07-20', 3000 , 12000 , 'N' ),
( 'MARIA'   , 1 , '1987-05-15' , 4 , 4 , '2007-07-20', 4000 , 13000 , 'N' ),
( 'JOÃO'    , 1 , '1988-06-16' , 5 , 5 , '2007-07-20', 5000 , 14000 , 'S' )

CREATE TABLE TB_DEPENDENTE
(
	CODFUN				INT			NOT NULL,
	CODDEP				INT			NOT NULL,
	NOME				VARCHAR(50)	NOT NULL,
	DATA_NASCIMENTO		DATE		NOT NULL

	CONSTRAINT	PK_TB_DEPENDENTE_CODDEP	PRIMARY KEY (CODDEP),
	CONSTRAINT	FK_TB_DEPENDENTE_CODFUN	FOREIGN KEY (CODFUN)	REFERENCES TB_EMPREGADO(CODFUN)
)

INSERT TB_DEPENDENTE
( CODFUN , CODDEP , NOME		, DATA_NASCIMENTO )
VALUES
( 1		 , 1001   , 'MARIA LUZ'	, '2014-01-10' ),
( 2		 , 1002   , 'ISABELLA'	, '2015-01-10' ),
( 3		 , 1003   , 'MARTA'	    , '2016-01-10' ),
( 4		 , 1004   , 'EMMY'	    , '2017-01-10' ),
( 5		 , 1005   , 'EMILLY'	, '2018-01-10' )

SELECT * FROM TB_DEPARTAMENTO
SELECT * FROM TB_CARGO
SELECT * FROM TB_EMPREGADO
SELECT * FROM TB_DEPENDENTE


-- IMPORTAÇÃO DE BANCO DE DADOS PRONTO:				PEDIDOS (IMPACTA CERTIFICAÇÕES)
USE MASTER
DROP DATABASE RH

CREATE DATABASE RH

-- 1º PASSO: SALVAR OS ARQUIVOS DO BANCO DE DADOS PEDIDOS (.MDF, .LDF, .NDF) EM UMA PASTA SEGURA

-- 2º PASSO: COPIAR OS ARQUIVOS DESTA PASTA PARA A PASTA DE DADOS DO SQL
-- MINHA MÁQUINA:
-- C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA

-- 3º PASSO: IMPORTAR OS ARQUIVOS UTILIZANDO UM SQL WIZARD

-- EXERCICIO: IMPORTAR O BANCO DE DADOS PEDIDOS UTILIZANDO O PASSO A PASSO ACIMA (5 MIN)
USE PEDIDOS

SELECT * FROM TB_ITENSPEDIDO
SELECT * FROM TB_CARGO

-- PROCESSAMENTO DE UM SCRIPT DE BANCO DE DADOS:	TSQL2012 (MICROSOFT CERTIFICAÇÕES)

-- PASSO ÚNICO: COPIAR O ARQUIVO .SQL DO CLASSROOM E EXECUTAR O CÓDIGO POR COMPLETO.


-- INTRODUÇÃO DO DATA QUERY LANGUAGE (DQL)

-- EM PARALELO: DATA MANIPULATION LANGUAGE (DML) [UPDATE, DELETE, INSERT]

-- ORDEM DOS COMANDOS NO SELECT
SELECT	
FROM	
WHERE
-- GROUP BY		(MAIS PRA FRENTE...)
-- HAVING		(MAIS PRA FRENTE...)
ORDER BY

-- POR ENQUANTO EU ESTAVA FAZENDO SELECT COM * (TODAS AS COLUNAS)
SELECT		*
FROM		TB_EMPREGADO

-- POSSO TRAZER AS MINHAS COLUNAS, EM QUALQUER ORDEM E TAMBÉM MANIPULANDO O RESULTADO
SELECT		SALARIO		,	SINDICALIZADO	,	NOME	,	SALARIO		,	SALARIO
FROM		TB_EMPREGADO

-- POSSO INCLUIR UMA COLUNA QUE NÃO EXISTA NA TABELA, COMO POR EXEMPLO, UMA CONSTANTE
-- PEDIDO: SELECIONAR O NOME, SALARIO, CONDIÇÃO SINDICAL E UMA COLUNA COM A INFORMAÇÃO 'IMPACTA'
-- OBS.: SEMPRE QUE EU TROUXER ALGUMA INFORMAÇÃO QUE NÃO EXISTE NA TABELA, OU QUE EU MANIPULAR, 
--       UM CAMPO, A COLUNA APARECERÁ SEM NOME.
-- SOLUÇÃO PARA ISSO: UTILIZAR O COMANDO ALIAS "AS"

SELECT		NOME, SALARIO, SINDICALIZADO, 'IMPACTA' AS FACULDADE
FROM		TB_EMPREGADO

-- EXERCICIO: ENCONTRAR A TABELA DE CLIENTES (BANCO DE DADOS PEDIDOS) E RETORNAR O SEGUINTE...
-- NOME, CNPJ, ESTADO E UMA COLUNA COM A DATA E HORA ATUAIS. A NOVA COLUNA SE CHAMARÁ DATA_ATUAL.
SELECT		NOME, CNPJ, ESTADO, GETDATE() AS DATA_ATUAL
FROM		TB_CLIENTE

-- ALIAS: COLUNA [AS] NOVO_NOME_COLUNA

-- NOME, SALARIO, PREMIO_MENSAL
SELECT		NOME, SALARIO, PREMIO_MENSAL
FROM		TB_EMPREGADO

-- WHERE: CONDIÇÃO DE PESQUISA OU FILTRO PARA O SELECT
SELECT	*
FROM	TB_EMPREGADO
WHERE	SALARIO <> 1200

-- OPERADORES...

-- OPERADORES DE COMPARAÇÃO ESCALAR (OU SÓ OPERADORES DE COMPARAÇÃO)
-- = (IGUAL), <> (DIFERENTE), > (MAIOR), >= (MAIOR OU IGUAL), < (MENOR), <= (MENOR OU IGUAL)
-- !{OPERADOR}: A EXCLAMAÇÃO NEGA O OPERADOR QUE SE SEGUE
-- != (NÃO IGUAL = DIFERENTE) 

-- EXERCICIOS:
-- 1. SELECIONAR TODOS OS COLABORADORES DA EMPRESA, QUE SEJAM SINDICALIZADOS
SELECT		*
FROM		TB_EMPREGADO
WHERE		SINDICALIZADO = 'S'

-- 2. SELECIONAR TODOS OS COLABORADORES, QUE POSSUAM CARGO DIFERENTE DE 14
SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO <> 14

-- TOTAL DA TABELA:		61 LINHAS
-- DIFERENTE DE 14 SÃO  55 LINHAS
-- QUANTOS SÃO OS REGISTROS IGUAIS A 14: 03 LINHAS
-- ONDE FORAM PARAR OS 03 REGISTROS? SÃO CAMPOS SEM CONTEÚDO (OU NULL)

-- PARA SE CAPTURAR OS NULOS, EU LEMBRO QUE ELE "É NULO!" OU ELE "NÃO É NULO"
SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO IS NULL

SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO IS NOT NULL

-- OPERADORES LÓGICOS: AND, OR, NOT
-- AND: SOMAR CONDIÇÕES, AUMENTANDO O FILTRO
-- CASE DA LOJA DE SAPATO: NIKE (1000) E BRANCO (400) E 41 (10) E 12 MOLAS (1)

-- OR:  ALTERNAR CONDIÇÕES, AUMENTANDO O RETORNO
-- CASE DA LOJA DE SAPATO: NIKE (1000) OU BRANCO (1000+200 MIZUNO) OU 41 (1000+200+41 OUTRAS MARCAS E OUTRAS CORES)...

SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO <> 14
 OR			COD_CARGO IS NULL

-- OUTRO EXEMPLO: SELECIONAR TODOS OS COLABORADORES QUE POSSUAM SALARIO ACIMA DE 3000
--                E QUE SEJAM SINDICALIZADOS
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO > 3000 
  AND		SINDICALIZADO = 'S'

-- + UM EXEMPLO: SELECIONAR TODOS OS COLABORADORES QUE GANHEM MAIS DO QUE 8000 OU QUE
--               NÃO SEJAM SINDICALIZADOS
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO > 8000 
  OR		SINDICALIZADO = 'N'

-- EXERCÍCIO DE PRESENÇA: SELECIONAR OS FUNCIONÁRIOS QUE GANHEM MENOS DO 2000
--                        E TAMBÉM OS FUNCIONÁRIOS QUE GANHEM MAIS DO QUE 5000
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO < 2000 
  OR		SALARIO > 5000

-- OPERADORES DE COMPARAÇÃO (OK)
-- OPERADORES LÓGICOS (OK)
-- OPERADORES MATEMÁTICOS: + , - , / , * , % (RESTO DA DIVISÃO) 
USE PEDIDOS

SELECT		NOME, NUM_DEPEND, NUM_DEPEND + 1 AS NOVA_COLUNA
FROM		TB_EMPREGADO

-- EXEMPLO: DETERMINAR SE UM CAMPO É PAR OU ÍMPAR
SELECT		NOME, NUM_DEPEND, NUM_DEPEND % 2 AS PAR_OU_IMPAR
FROM		TB_EMPREGADO

-- EXEMPLO: UTILIZANDO O OPERADOR MATEMÁTICO NO WHERE
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO + 2000 > 10000

-- EXERCÍCIO: DIA DO DISSÍDIO... REALIZAR AUMENTO DE 8% NO SALÁRIO DE TODOS OS EMPREGADOS SINDICALIZADOS
SELECT		NOME, SINDICALIZADO, SALARIO, (SALARIO * 0.08) + SALARIO AS NOVO_SALARIO
FROM		TB_EMPREGADO
WHERE		SINDICALIZADO = 'S'

SELECT		NOME, SINDICALIZADO, SALARIO, SALARIO * 1.08 AS NOVO_SALARIO
FROM		TB_EMPREGADO
WHERE		SINDICALIZADO = 'S'

-- ERRO: NÃO POSSO UTILIZAR O ALIAS DURANTE SUA CRIAÇÃO
SELECT		NOME, SINDICALIZADO, SALARIO, SALARIO * 0.08 AS AUMENTO, SALARIO + AUMENTO
FROM		TB_EMPREGADO
WHERE		SINDICALIZADO = 'S'

-- BETWEEN ("ENTRE" EM INGLÊS): RANGE DE VALORES DENTRO DO FILTRO
-- EXEMPLO: SELECIONAR TODOS OS PEDIDOS QUE POSSUAM VALOR TOTAL ENTRE 100 E 200
SELECT	* 
FROM	TB_PEDIDO
WHERE	VLR_TOTAL BETWEEN 100 AND 200

SELECT	* 
FROM	TB_PEDIDO
WHERE	VLR_TOTAL >= 100 AND VLR_TOTAL <= 200

-- EXERCICIO: SELECIONAR TODOS OS EMPREGADOS QUE POSSUAM DATA DE ADMISSAO NA DÉCADA DE 80
-- FUNCIONÁRIOS ADMITIDOS DE 01/01/1980 A 31/12/1989
SELECT	* 
FROM	TB_EMPREGADO
WHERE	DATA_ADMISSAO BETWEEN '1980.01.01' AND '1989-31-12' -- DATA NA MINHA MÁQ ESTÁ FORMATO AAAA-DD-MM

-- FUNÇÕES DE TRATAMENTO DE DATA:
-- YEAR(CAMPO):		EXIBE O ANO DE UM DETERMINADO CAMPO DE DATA
-- MONTH(CAMPO):	EXIBE O MÊS DE UM DETERMINADO CAMPO DE DATA
-- DAY(CAMPO):		EXIBE O DIA DE UM DETERMINADO CAMPO DE DATA

SELECT GETDATE(), YEAR(GETDATE()) AS ANO, MONTH(GETDATE()) AS MÊS, DAY(GETDATE()) AS DIA

-- UTILIZANDO AS FUNÇÕES DE DATA, O EXERCÍCIO PODERIA FICAR ASSIM:
SELECT	* 
FROM	TB_EMPREGADO
WHERE	YEAR(DATA_ADMISSAO) BETWEEN 1980 AND 1989

-- EXERCICIO: SELECIONAR TODOS OS PEDIDOS, QUE FORAM FEITOS EM DIAS ÍMPARES
SELECT	*, DAY(DATA_EMISSAO) AS DIA, DAY(DATA_EMISSAO) % 2 AS RESTO 
FROM	TB_PEDIDO
WHERE	DAY(DATA_EMISSAO) % 2 = 1

-- IN: FAZ UMA SELEÇÃO DENTRO DE UM ARRAY (LISTA) DE POSSIBILIDADES
-- EXEMPLO: SELECIONAR OS EMPREGADOS DOS CARGOS 1, 2, 3, 5, 10, 12, 16, 30
SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO IN ( 1 , 2 , 3 , 5 , 10 , 12, 16 , 30 ) 

-- EXEMPLO: SELECIONAR OS EMPREGADOS QUE NÃO ESTEJAM NOS CARGOS 1, 2, 3, 5, 10, 12, 16, 30
SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO NOT IN ( 1 , 2 , 3 , 5 , 10 , 12, 16 , 30 )

-- LIKE: FAZ UMA BUSCA APROXIMADA DE UMA INFORMAÇÃO ALFANUMÉRICA
-- LIKE SEM AUXILIARES, POSSUI A MESMA FUNÇÃO DE UM "="

-- AUXILIARES:
-- %: CORINGA, OU SEJA, ELE SUBSTITUI, TUDO QUE VEM ANTES OU DEPOIS, CONFORME SUA POSIÇÃO
-- _: SUBSTITUTO DE UM ÚNICO CARACTERE (CORINGA CHAR(01))
-- [CH OU LISTA DE CH]: CADA CONJUNTO DE COLCHETES, SUBSTITUI UMA POSIÇÃO (CHAR(01)) PORÉM COM UMA LISTA PRÉ DEFINIDA
-- [^CH OU LISTA DE CH]: NEGA O CONJUNTO DE CARACTERES DENTRO DO COLCHETE, CRIANDO UMA CONDIÇÃO CONTRÁRIA
-- [CH01-CH02]: INSERE UMA LISTA DE OPÇÕES ORDENADAS ALFABETICAMENTE ENTRE CH01 E CH02
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE 'OLAVO%'

INSERT TB_EMPREGADO ( NOME ) VALUES ('OLAVO SETÚBAL')

-- EXERCÍCIO: ENCONTRAR TODOS OS COLABORADORES QUE POSSUAM "SILV" NO NOME
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%SILV%'

-- EXEMPLO: ENCONTRAR TODOS OS COLABORADORES QUE O NOME COMECE COM "A" E QUE POSSUA "L" 
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE 'A%L%'

-- EXEMPLO: SELECIONAR OS PRODUTOS QUE POSSUAM "A" NA TERCEIRA POSIÇÃO  
SELECT	* 
FROM	TB_PRODUTO
WHERE	DESCRICAO LIKE '__A%'

-- EXERCICIO: SELECIONAR TODOS OS COLABORADORES QUE POSSUAM SOBRENOME SOUZA/SOUSA
SELECT	*
FROM	TB_EMPREGADO
WHERE	NOME LIKE '%SOU_A%'

INSERT TB_EMPREGADO ( NOME ) VALUES ('ALBERTO SOUPA')

-- ALTERANDO PARA NÃO QUEBRAR NA CONDIÇÃO DE EXISTIR SOU*A. DEIXANDO APENAS "SOU (S OU Z) A"
SELECT	*
FROM	TB_EMPREGADO
WHERE	NOME LIKE '%SOU[SZ]A%'

-- EXERCICIO: EXIBIR TODOS OS PRODUTOS QUE INICIEM COM VOGAL
SELECT		*
FROM		TB_PRODUTO
WHERE		DESCRICAO LIKE '[AEIOU]%'

-- SE EU MUDAR O EXERCÍCIO ACIMA PARA RETORNAR TODOS OS QUE INICIEM COM CONSOANTE
SELECT		*
FROM		TB_PRODUTO
WHERE		DESCRICAO LIKE '[^AEIOU]%'

SELECT		*
FROM		TB_PRODUTO
WHERE		DESCRICAO NOT LIKE '[AEIOU]%'

-- EXEMPLO: SELECIONAR TODOS OS PRODUTOS QUE INICIEM COM LETRAS DE "A" A "J"
SELECT		*
FROM		TB_PRODUTO
WHERE		DESCRICAO LIKE '[A-J]%'

-- ORDER BY: REALIZA UMA ORDENAÇÃO DA LISTA RESULTANTE (RESULT SET)
-- EXEMPLO: ORDENAR ALFABETICAMENTE OS NOMES DOS EMPREGADOS
-- ASC  (ASCENDENTE): DO MENOR PARA O MAIOR (DEFAULT)
-- DESC (DESCENDENTE): DO MAIOR PARA O MENOR
SELECT		*
FROM		TB_EMPREGADO
ORDER BY	NOME DESC

-- EXEMPLO: ORDENAR A LISTA CONSIDERANDO MAIS DE UM CRITÉRIO DE ORDENAÇÃO
--          ORDENAR AS QUANTIDADES DE DEPENDENTES E A CONDIÇÃO SINDICAL
SELECT		*
FROM		TB_EMPREGADO
ORDER BY	NUM_DEPEND DESC, SINDICALIZADO ASC

SELECT		*
FROM		TB_ITENSPEDIDO						-- 0.041 SEG (TABELA TODA)
WHERE		NUM_PEDIDO = 2 AND NUM_ITEM = 1		-- 0.000 SEG (BUSCANDO COM CHAVE PRIMÁRIA)

SELECT		*
FROM		TB_ITENSPEDIDO						-- 0.041 SEG (TABELA TODA)
ORDER BY	DESCONTO DESC, ID_PRODUTO ASC, COD_PRODUTO DESC, CODCOR ASC, QUANTIDADE DESC, PR_UNITARIO ASC, DATA_ENTREGA DESC
												-- 0.017 SEG (BUSCA)
												-- 0.057 SEG (ORDENAÇÃO)
												-- 0.102 SEG (PARALELISMO)

-- RANKING: ORDER BY + TOP
-- TOP (N) / TOP (N) PERCENT: APÓS O COMANDO SELECT E ANTES DA LISTA DE CAMPOS, INSERIR A CLÁUSULA TOP
--                            LIMITA O MEU RETORNO A UMA AMOSTRA DA TABELA
SELECT		TOP 2 NOME , SALARIO, PREMIO_MENSAL
FROM		TB_EMPREGADO

SELECT		TOP 10 PERCENT *
FROM		TB_EMPREGADO

-- EXEMPLOS: SELECIONAR OS 5 PRODUTOS MAIS CAROS (SEGUNDO O PRECO_VENDA) DO MEU ESTOQUE
SELECT		TOP 5 *
FROM		TB_PRODUTO
ORDER BY	PRECO_VENDA DESC

-- EXERCICIO: SELECIONAR OS 10 EMPREGADOS MAIS BEM PAGOS (SEGUNDO O SALÁRIO)
-- CASE: OS 10 MAIORES SALÁRIOS SERÃO PREMIADOS COM UM CARRO ZERO!
SELECT		TOP 15 * 
FROM		TB_EMPREGADO
ORDER BY	SALARIO DESC

-- COMANDO: WITH TIES (SÓ É UTILIZADO EM RANKINGS, OU SEJA, TOP N + ORDER BY)
SELECT		TOP 10 WITH TIES * 
FROM		TB_EMPREGADO
ORDER BY	SALARIO DESC

-- EXERCÍCIOS DE FIXAÇÃO
USE TSQL2012
-- 1. Construa duas consultas que retornem o Número do Produto (productid), Nome (productname) e 
-- Preço (unitprice) onde os preços estejam entre 19 e 22. Construir a 1ª. consulta, 
-- utilizando o operador AND. 
SELECT		productid, productname, unitprice
FROM		Production.Products
WHERE		unitprice >= 19 AND unitprice <= 22

-- Na 2ª. Consulta, que deverá retornar exatamente as mesmas colunas e linhas, utilizar o predicado BETWEEN. 
-- (tabela Production.Products)
SELECT		productid, productname, unitprice
FROM		Production.Products
WHERE		unitprice BETWEEN 19 AND 22

-- CHECKPOINT DOS EXERCÍCIOS DE FIXAÇÃO: 22:15H
-- 3. Retorne o Número do Empregado (empid), Título (titleofcourtesy), a Data de Nascimento (birthdate) 
-- e concatenar as colunas nome (firstname) e sobrenome (lastname) em apenas uma coluna apelidada de 
-- Nome Completo,  apenas para os empregados que nasceram em qualquer dia e mês desde 1947 até 1965. 
-- (tabela HR.Employees)

-- CONCATENAÇÃO: CONCAT(CAMPO1, CAMPO2,..., CAMPON)
--               CAMPO_ALFANUMÉRICO + CAMPO_ALFANUMÉRICO
SELECT		empid, titleofcourtesy, birthdate, firstname + ' ' + lastname AS NomeCompleto
FROM		HR.Employees
WHERE		YEAR(birthdate) BETWEEN 1947 AND 1965

SELECT		empid, titleofcourtesy, birthdate, CONCAT( firstname , ' ' , lastname ) AS NomeCompleto
FROM		HR.Employees
WHERE		YEAR(birthdate) BETWEEN 1947 AND 1965

-- ATIVIDADE CONTÍNUA 02
-- ENTREGAR O CÓDIGO SQL CORRESPONDENTE ÀS QUESTÕES ABAIXO
-- BANCO DE DADOS: PEDIDOS
USE PEDIDOS
-- 01. RETORNE NOME, SALÁRIO, PREMIO MENSAL, CONDIÇÃO SINDICAL E CÓDIGO DO CARGO
--     PARA TODOS OS COLABORADORES QUE SEJAM SINDICALIZADOS E ESTEJAM NOS CARGOS ÍMPARES
--	   TABELA: TB_EMPREGADO
SELECT		NOME, SALARIO, PREMIO_MENSAL, SINDICALIZADO, COD_CARGO 
FROM		TB_EMPREGADO
WHERE		SINDICALIZADO = 'S' 
  AND		COD_CARGO % 2 =  1

-- 02. SELECIONE OS 10 PRODUTOS MAIS CAROS DA TABELA PRODUTOS (CONSIDERAR PRECO_VENDA)
--     TABELA: TB_PRODUTO
SELECT		TOP 10 WITH TIES *
FROM		TB_PRODUTO
ORDER BY	PRECO_VENDA DESC

-- 03. SELECIONA OS TODOS OS PEDIDOS (TABELA: TB_ITENSPEDIDO) QUE  FORAM FEITOS NOS
--     MESES DE JANEIRO, FEVEREIRO OU MARÇO, DE QUALQUER ANO.
SELECT		*
FROM		TB_ITENSPEDIDO
WHERE		MONTH(DATA_ENTREGA) = 01 OR MONTH(DATA_ENTREGA) = 02 OR MONTH(DATA_ENTREGA) = 03

SELECT		*
FROM		TB_ITENSPEDIDO
WHERE		MONTH(DATA_ENTREGA) IN ( 01 , 02 , 03 )

-- 04. SELECIONE TODOS OS PEDIDOS (TABELA DE PEDIDOS) QUE POSSUAM A LITERAL 'CANETA'
--     EM QUALQUER PARTE DO CAMPO OBSERVACOES
--     RETORNAR NA LISTA APENAS CASO O CÓDIGO DO VENDEDOR SEJA MENOR DO QUE 10
SELECT	*
FROM	TB_PEDIDO
WHERE	OBSERVACOES LIKE '%CANETA%'
  AND	CODVEN < 10

-- 05. SELECIONAR OS CLIENTES (TABELA TB_CLIENTE) QUE MOREM EM CIDADES ONDE 
-- A TERCEIRA LETRA SEJA UMA VOGAL.
SELECT		*
FROM		TB_CLIENTE
WHERE		CIDADE LIKE '__[AEIOU]%'

-- 06. AINDA NESTA TABELA, OBTER A LISTA DE CLIENTES QUE ESTEJAM NOS ESTADOS DO SUL E SUDESTE
--     CAMPOS A SELECIONAR: NOME, FANTASIA, CIDADE, ESTADO, E A DIFERENÇA ENTRE O 
--     ANO DA DATA DE CADASTRO E O ANO DA DATA ATUAL
SELECT		NOME, FANTASIA, CIDADE, ESTADO,
			YEAR(GETDATE()) - YEAR(DATA_CAD) AS IDADE_CADASTRO
FROM		TB_CLIENTE
WHERE		ESTADO IN ( 'PR' , 'SC' , 'RS' , 'SP' , 'RJ' , 'MG' , 'ES' )

-- 07. SELECIONAR OS FUNCIONÁRIOS QUE POSSUAM SALÁRIO ACIMA DE 3500.
--     RETORNAR TODOS OS CAMPOS DA TABELA E TAMBÉM UM CAMPO ADICIONAL COM A CONSTANTE
--     'FACULDADE IMPACTA'. ESTE NOVO CAMPO DEVERÁ SE CHAMAR 'ORIGEM'.
SELECT		* , 'FACULDADE IMPACTA' AS ORIGEM
FROM		TB_EMPREGADO
WHERE		SALARIO >= 3500

-- 08. TRAZER O NOME DOS FUNCIONÁRIOS, SEU SALÁRIO, PREMIO MENSAL E DATA DE NASCIMENTO.
--     CRIAR TAMBÉM UM CAMPO COM O SALÁRIO DE TODOS OS FUNCIONÁRIOS ACRESCIDOS DE 15%
--     ALÉM DISSO, CRIAR UM SEGUNDO CAMPO SOMANDO A METADE DO PREMIO MENSAL COM METADE
--     DO NOVO VALOR DO SALÁRIO (SALÁRIO JÁ ACRESCIDO DE 15%).
--     ESTA OPERAÇÃO SERÁ REALIZADA APENAS PARA PROFISSIONAIS NASCIDOS EM ANOS PARES
--     E MESES ÍMPARES.
SELECT	NOME, SALARIO, PREMIO_MENSAL, DATA_NASCIMENTO,
		SALARIO * 1.15 AS NOVO_SALARIO, 
		(PREMIO_MENSAL / 2) + (SALARIO * 1.15 / 2) AS NOVO_BONUS
FROM	TB_EMPREGADO
WHERE	YEAR(DATA_NASCIMENTO) % 2 = 0
  AND	MONTH(DATA_NASCIMENTO) % 2 = 1

-- EXEMPLO DA "DANIELA ALEXANDRA DA SILVA":
SELECT 	NOME, DATA_NASCIMENTO, PREMIO_MENSAL,SALARIO + (SALARIO*0.15) AS 'QUINZE%', 
		CAST((PREMIO_MENSAL/2)+ ((SALARIO + SALARIO * 0.15) /2) AS decimal(9,2)) AS METADE_REAL 
FROM TB_EMPREGADO 
WHERE YEAR(DATA_NASCIMENTO)% 2 =0 AND MONTH(DATA_NASCIMENTO) %2 = 1

-- FUNÇÃO CAST: SINTAXE CAST(CAMPO AS NOVO_FORMATO)
SELECT	NOME, CAST(SALARIO * 1.259 AS DECIMAL(9,2))
FROM	TB_EMPREGADO

-- FUNÇÕES DE TRATAMENTO DE DATA:
-- YEAR(CAMPO_DATA):	EXIBE O ANO DE UM DETERMINADO CAMPO DE DATA
-- MONTH(CAMPO_DATA):	EXIBE O MÊS DE UM DETERMINADO CAMPO DE DATA
-- DAY(CAMPO_DATA):		EXIBE O DIA DE UM DETERMINADO CAMPO DE DATA

SELECT GETDATE(), YEAR(GETDATE()) AS ANO, MONTH(GETDATE()) AS MÊS, DAY(GETDATE()) AS DIA

-- UTILIZANDO AS FUNÇÕES DE DATA, O EXERCÍCIO PODERIA FICAR ASSIM:
SELECT	* 
FROM	TB_EMPREGADO
WHERE	YEAR(DATA_ADMISSAO) BETWEEN 1980 AND 1989

-- INÍCIO DA CORREÇÃO:  19:30H
-- TÉRMINO DA CORREÇÃO: 20:00H

-- RELEMBRANDO E ADICIONANDO COMPLEXIDADE AS CONSTRAINTS:
-- CHECK
-- DEFAULT
CONSTRAINT CK_emp_id 
CHECK (emp_id LIKE '[A-Z][A-Z][A-Z][1-9][0-9][0-9][0-9][0-9][FM]')

DROP TABLE TB_CADASTRO

CREATE TABLE TB_CADASTRO
(
	CPF				CHAR(12)	,
	NOME			VARCHAR(50) ,

	CONSTRAINT	CK_CPF	CHECK (CPF LIKE '[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][-][0-9][0-9]')
)

-- EXERCÍCIO: BASEADO NO EXEMPLO DE UTILIZAÇÃO DA CONSTRAINTS CHECK, 
--            GARANTA QUE TODOS OS 9 PRIMEIROS REGISTROS DO CPF SEJAM NUMÉRICOS
--            QUE O DÉCIMO DÍGITO SEJA UM HÍFEM E QUE OS DOIS ÚLTIMOS SEJAM NUMÉRICOS
INSERT TB_CADASTRO
( CPF , NOME )
VALUES
( '123456789-19', 'TESTE DE CPF')

SELECT * FROM TB_CADASTRO

-- ALTER TABLE:
-- SINTAXE: ALTER TABLE <NOME_TABELA> OPERAÇÃO_CONTRAINT <NOME_CONSTRAINT>
ALTER TABLE TB_CADASTRO Drop Constraint CK_CPF

ALTER TABLE TB_CADASTRO Add Constraint CK_CPF CHECK (CPF LIKE '[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][-][0-9][0-9]')

-- INSERIR COLUNA
-- DELETAR COLUNA
-- INSERIR IDENTITY...
-- NOS EXERCÍCIOS, QUANDO ENCONTRAR A NECESSIDADE, PESQUISAR! [DOCS MICROSOFT OU DEVMEDIA]

-- DATA MANIPULATION LANGUAGE (INSERT, DELETE, UPDATE, TRUNCATE)
-- INSERT: INSERIR DADOS EM UMA TABELA OU VIEW
-- SINTAXE: INSERT [INTO] table_or_view [(column_list)] VALUES data_values
INSERT TB_CADASTRO
VALUES
( '123456789-19', 'TESTE DE CPF')
-- OBSERVAÇÃO: É OBRIGATÓRIO, INSERIR VALORES PARA TODAS AS COLUNAS

-- INSERT UTILIZANDO SELECT
-- NECESSIDADE: INSERIR TODOS OS NOMES DE FUNCIONÁRIOS SINDICALIZADOS NA TABELA DE CADASTRO
INSERT TB_CADASTRO
( CPF , NOME )
VALUES
( ... TODOS OS NOMES DE FUNCIONÁRIOS SINDICALIZADOS ...)

INSERT TB_CADASTRO
( CPF , NOME )
-- VALUES
SELECT	999 , NOME
FROM	TB_EMPREGADO
WHERE	SINDICALIZADO = 'S'

SELECT * FROM TB_CADASTRO

-- INSERT COM TOP (N)
INSERT TOP (10) TB_CADASTRO
( CPF , NOME )
SELECT	999 , NOME
FROM	TB_EMPREGADO
WHERE	SINDICALIZADO = 'S'

SELECT * FROM TB_CADASTRO

-- "INSERT" COM SELECT INTO
-- NESSE CASO, EU CRIO UMA TABELA E INSIRO DADOS DURANTE O PROCESSAMENTO DO SELECT
-- SINTAXE: REDIGIR O COMANDO SELECT DESEJADO 
-- E ANTES DO PRIMEIRO FROM INSERIR "INTO <NOME_NOVA_TABELA>"

-- NECESSIDADE: CRIAR UMA TABELA COM TODOS OS FUNCIONÁRIOS NÃO SINDICALIZADOS
SELECT		*
INTO		TB_EMPREGADO_NAO_SIND
FROM		TB_EMPREGADO
WHERE		SINDICALIZADO = 'N'

SELECT * FROM TB_EMPREGADO_NAO_SIND

-- OBSERVAÇÃO RELEVANTE: AO PROCESSAR UM SELECT INTO, A NOVA TABELA VIRÁ SEM CONSTRAINTS

-- DELETE: REMOVE LINHAS DE UMA TABELA OU VIEW
-- SINTAXE: DELETE	table_or_view
--          FROM	table_sources
--			WHERE	search_condition

-- DELETE SEM WHERE
SELECT * FROM TB_EMPREGADO_NAO_SIND

DELETE FROM TB_EMPREGADO_NAO_SIND

-- DELETE COM WHERE
SELECT * FROM TB_CADASTRO

DELETE FROM TB_CADASTRO WHERE NOME LIKE '%OLAVO%'

-- DELETE COM TOP (N)
SELECT * FROM TB_CADASTRO WHERE NOME LIKE '%SILVA%'

DELETE TOP (3) FROM TB_CADASTRO WHERE NOME LIKE '%SILVA%'

-- DELETE UTILIZANDO UMA SUBQUERY
-- NECESSIDADE: DELETAR TODOS OS DEPENDENTES DOS FUNCIONÁRIOS DE SALÁRIO ACIMA DE 3000
SELECT	CODFUN
FROM	TB_EMPREGADO
WHERE	SALARIO > 3000

SELECT	*
FROM	TB_DEPENDENTE
WHERE	CODFUN IN (7,16,18,19,25,26,27,28,31,32,33,43,46,51,53,58,59,61,66,69,72)

DELETE FROM TB_DEPENDENTE
WHERE	CODFUN IN ( SELECT	CODFUN
					FROM	TB_EMPREGADO
					WHERE	SALARIO > 3000 )

-- TRUNCATE: APAGA TODOS OS REGISTROS DE UMA TABELA
-- O TRUNCATE FAZ PARTE DE UM TIPO DE COMANDO CHAMADO "LOG LESS", NAO GRAVA LOG
INSERT TB_ITENS_GRANDE
SELECT	* 
FROM	TB_ITENSPEDIDO

SELECT * FROM TB_ITENS_GRANDE -- 1.494.507 LINHAS

DELETE FROM TB_ITENS_GRANDE -- 1.494.507 LINHAS DEMORA CERCA DE 4 SEGUNDOS

TRUNCATE TABLE TB_ITENS_GRANDE

-- UPDATE: ATUALIZA OS DADOS DE UMA TABELA
-- SINTAXE: UPDATE	table_or_view
--			SET		column_name = NEW_expression
--			FROM	table_sources
--			WHERE	search_condition

-- UPDATE SEM WHERE
SELECT * FROM TB_EMPREGADO

UPDATE	TB_EMPREGADO
SET		SALARIO = 10000

-- UPDATE COM WHERE
UPDATE	TB_EMPREGADO
SET		SALARIO = 1000 , PREMIO_MENSAL = 10000
WHERE	NOME LIKE '%OLAVO%'

-- UPDATE UTILIZANDO UMA SUBQUERY
-- NECESSIDADE: AUMENTAR EM 10 UNID, O DESCONTO DE TODOS OS ITENS DE PEDIDO 
--              QUE POSSUAM PRECO_CUSTO MENOR DO QUE 1 REAL
SELECT	ID_PRODUTO 
FROM	TB_PRODUTO
WHERE	PRECO_CUSTO < 1

SELECT TOP 1 * FROM TB_ITENSPEDIDO

UPDATE	TB_ITENSPEDIDO
SET		DESCONTO = DESCONTO + 10
WHERE	ID_PRODUTO IN ( SELECT	ID_PRODUTO 
						FROM	TB_PRODUTO
						WHERE	PRECO_CUSTO < 1  )

-- É UMA POSSIBILIDADE, TAMBÉM UTILIZAR O UPDATE TOP (N) <NOME_TABELA>


USE Concessionaria
-- 1. Altere as colunas DESCRICAO para um campo variável de 30 caracteres, obrigatório.
ALTER TABLE MODELO ALTER COLUMN DESCRICAO VARCHAR(30) NOT NULL
ALTER TABLE VEICULO ALTER COLUMN DESCRICAO VARCHAR(30) NOT NULL

-- 2. Insira o campo string variável de tamanho 20, de nome StatusVeiculo 
-- na tabela Veiculo.
ALTER TABLE VEICULO ADD StatusVeiculo VARCHAR(20)

SELECT * FROM Veiculo

-- 3. Elimine a coluna CONTATO da tabela Fabricante.
ALTER TABLE FABRICANTE DROP COLUMN CONTATO

-- 4. Altere a tabela Veiculo para que a coluna StatusVeiculo tenha como valor padrão 
-- o texto ATIVO.
ALTER TABLE Veiculo Add Constraint DF_STATUS_VEICULO DEFAULT ('ATIVO') FOR StatusVeiculo 

SELECT * FROM Veiculo
INSERT Veiculo
( descricao, valor, dataCompra, StatusVeiculo)
VALUES
('Bandit 650' , 22000 , '2000-01-01', 'INATIVO')

-- 5. Altere a tabela Vendas Anuais para que a coluna QTD aceite valores entre 1 e 10000. 
-- (se houver valores fora desta faixa, usar a declaração DELETE para eliminar estes registros)
SELECT		*
FROM		VendasAnuais
ORDER BY	QTD

ALTER TABLE VendasAnuais Add Constraint CK_QTD CHECK (QTD BETWEEN 1 AND 10000)

DELETE FROM VendasAnuais
WHERE qtd < 1 OR qtd > 10000

-- REVISÃO!
-- EXERCÍCIOS DE FIXAÇÃO (6 AO 14 DO MATERIAL DIDÁTICO) --> 30 MIN

-- 6. Insira os anos de 2016 até o ano corrente na tabela Ano.
USE Concessionaria

SELECT * FROM Ano

-- CASO FOSSE NECESSÁRIO REALIZAR:
INSERT Ano (ano) VALUES (2016),(2017),(2018),(2019),(2020),(2021)


-- 7. Insira os modelos LST, KS e RS na tabela Modelo
SELECT * FROM MODELO

INSERT Modelo (descricao) VALUES ('LST'), ('KS'), ('RS')

-- IDS: 10, 11 E 12

-- 8. Altere a tabela Mes, adicionando a coluna descricaoMes, de texto variável capaz de caber 
--    a maior das descrições dos meses (Janeiro, Fevereiro, ...).
SELECT * FROM MES

ALTER TABLE MES ADD descricaoMes VARCHAR(09)

-- 9. Faça UPDATEs na tabela MES, colocando as descrições respectivas na coluna criada, de 
--    acordo com o respectivo valor apresentado na coluna MES.
UPDATE	Mes			SET		DESCRICAOMES = 'Janeiro'	WHERE	Mes =  1
UPDATE	Mes			SET		descricaoMes = 'Fevereiro'	WHERE	Mes =  2
UPDATE	Mes			SET		descricaoMes = 'Março'		WHERE	Mes =  3
UPDATE	Mes			SET		descricaoMes = 'Abril'		WHERE	Mes =  4
UPDATE	Mes			SET		descricaoMes = 'Maio'		WHERE	Mes =  5
UPDATE	Mes			SET		descricaoMes = 'Junho'		WHERE	Mes =  6
UPDATE	Mes			SET		descricaoMes = 'Julho'		WHERE	Mes =  7
UPDATE	Mes			SET		descricaoMes = 'Agosto'		WHERE	Mes =  8
UPDATE	Mes			SET		descricaoMes = 'Setembro'	WHERE	Mes =  9
UPDATE	Mes			SET		descricaoMes = 'Outubro'	WHERE	Mes =  10
UPDATE	Mes			SET		descricaoMes = 'Novembro'	WHERE	Mes =  11
UPDATE	Mes			SET		descricaoMes = 'Dezembro'	WHERE	Mes =  12

UPDATE		Mes
SET			descricaoMes = CASE
								WHEN mes = 1 THEN 'Janeiro'
								WHEN mes = 2 THEN 'Fevereiro'
								WHEN mes = 3 THEN 'Março'
								WHEN mes = 4 THEN 'Abril'
								WHEN mes = 5 THEN 'Maio'
								WHEN mes = 6 THEN 'Junho'
								WHEN mes = 7 THEN 'Julho'
								WHEN mes = 8 THEN 'Agosto'
								WHEN mes = 9 THEN 'Setembro'
								WHEN mes = 10 THEN 'Outubro'
								WHEN mes = 11 THEN 'Novembro'
								WHEN mes = 12 THEN 'Dezembro'
							END


-- 10. Insira ao menos 3 Fabricantes (Triumph, KTM e Kymco) com informações reais para os campos 
--     da tabela.
select * from Fabricante

insert into Fabricante 
(Nome, endereco, cidade, UF, telefone) 
values
  ('Triumph', 'Rua Celta, 125', 'Sao Paulo', 'ES', '36454128')
, ('KTM', 'Rua Juí, 20', 'Sao Paulo', 'SP', '44456200')
, ('Kymco', 'Av. Delta, 150', 'Rio de Janeiro', 'RJ', '77785511') 

-- IDs: 10, 11 E 12

-- 11. Insira ao menos 3 registros (Tiger Explorer, ECX 450, Downtown) na Tabela Veículo, com valores 
--     reais para os campos de valor, dataCompra e variando as informações de modelo, ano e 
--     Fabricante com os INSERTS que foram feitos anteriormente.
select * from veiculo

insert into Veiculo 
(descricao,				  valor, dataCompra, idModelo,	idFabricante,	idAnoFabricacao) 
values
  ('Tiger Explorer'		, 53488, '20171020', 10,			10,				2)
, ('ECX 450'			, 45899, '20170901', 11,			11,				3)
, ('Downtown'			, 6550,  '20170820', 12,			12,				1)

-- IDs: 112, 113 e 114

-- 12. Para cada Veiculo inserido, insira ao menos 2 registros na tabela VendasAnuais para o Ano e 
--     Veículo inseridos, variando o mês e qtd.
SELECT * FROM VendasAnuais 

insert VendasAnuais 
(qtd,	idVeiculo, idAnodaVenda,	idMesdaVenda) 
values
(102,	112,		01,				15), 
(87,	112,		01,				18),
(90,	113,		02,				27), 
(48,	113,		02,				30),
(235,	114,		03,				45), 
(3,		114,		03,				18)

-- 13. Atualize o modelo LST para GTX.
select * from modelo

UPDATE Modelo SET descricao = 'GTX' WHERE descricao = 'LST'
UPDATE Modelo SET descricao = 'GTX' WHERE idModelo  =  10

-- 14. Escolha um dos veículos inseridos e monte a sequência de comandos para eliminar o registro 
--    (mais de uma tabela), de forma que o banco de dados não gere erro na execução desta sequência 
--    de deleção.
SELECT * FROM VendasAnuais 

DELETE FROM VendasAnuais WHERE idVeiculo = 112


SELECT * FROM Veiculo

DELETE FROM Veiculo WHERE idVeiculo = 112

-- LANÇAMENTO DA AC03 (DML) -- OK

-- CORREÇÃO DA AC03 (DML)
-- INÍCIO:  19:20h
-- TÉRMINO: 20:10h

-- Parte 1: Banco de Dados Concessionária
-- 1. Recriar toda a estrutura de tabelas (Script Carga Concessionaria)
-- (OK - PROCESSADO ARQUIVO EXISTENTE NO CLASSROOM)
USE Concessionaria

-- 2. Adicionar os fabricantes a seguir com todos dados: FIAT, GM e VW.
SELECT * FROM FABRICANTE

Insert Fabricante 
(nome,		endereco,					cidade,			uf,		telefone,	contato) 
values
('GM',		'Rua da Consolacao, 125',	'Sao Paulo',	'SP',	'26454128', 'Ismael Santos'),
('Volks',	'Rua Ipiranga, 820',		'Sao Paulo',	'SP',	'24456200', 'Ana Cristina'),
('Fiat',	'Av Paulista, 1009',		'Sao Paulo',	'SP',	'74648313', 'Fabiano Passos')

-- IDS: 10	GM, 11	Volks, 12	Fiat


-- 3. Adicionar os modelos: Standard, Premium, Executive.
SELECT * FROM MODELO

INSERT Modelo
VALUES
('Standard'), 
('Premium')  , 
('Executive')

-- IDS: 10	Standard, 11	Premium, 12	Executive

-- 4. Adicionar os Veículos: 
-- Artic (Fiat - Standard - ano 2025)
-- Voltz (GM - Executive - ano 2027) 
-- Zeo (Volks - Premium - ano 2028)
-- Bjorn (GM - Premium - ano 2028)
-- Duntzen (Fiat - Standard  ano 2026)
-- Tungsten (Volks - Executive - ano 2027)
SELECT * FROM Veiculo

-- IDS MODELO:		10	Standard, 11	Premium	, 12	Executive
-- IDS FABRICANTE:	10	GM		, 11	Volks	, 12	Fiat
-- IDS ANO:			26	2025	, 27	2026	, 28	2027,		29	2028

INSERT Veiculo
( descricao, valor , dataCompra, idModelo, idFabricante, idAnoFabricacao)
VALUES
( 'Artic'  , 101000, GETDATE() , 10		 , 12		   , 26 )

INSERT Veiculo
( descricao		,	valor	,	dataCompra	,	idModelo	,	idFabricante	,	idAnoFabricacao )
VALUES
('Voltz   '		,	102000	,	'2027-01-01',	12			,	10				,	28 ),
('Zeo     '		,	103000	,	'2028-01-01',	11			,	11				,	29 ),
('Bjorn   '		,	104000	,	'2028-01-01',	11			,	10				,	29 ),
('Duntzen '		,	105000	,	'2026-01-01',	10			,	12				,	27 ),
('Tungsten'		,	106000	,	'2027-01-01',	12			,	11				,	28 )


SELECT * FROM ANO

INSERT Ano
VALUES
( 2016 ), ( 2017 ), ( 2018 ), ( 2019 ), ( 2020 ), ( 2021 ),
( 2022 ), ( 2023 ), ( 2024 ), ( 2025 ), ( 2026 ), ( 2027 ), ( 2028 ) 

-- IDS (VEICULOS): 112 Artic,113 Voltz,114 Zeo, 115  Bjorn, 116 Duntzen, 117 Tungsten


-- 5. Adicionar três Vendas para cada veículo para o ano de 2029 em meses distintos.
SELECT * FROM VendasAnuais
SELECT * FROM ANO
SELECT * FROM MES


INSERT Ano
VALUES
( 2029 ) -- ID: 31

-- IDS (VEICULOS): 112 Artic,113 Voltz,114 Zeo, 115  Bjorn, 116 Duntzen, 117 Tungsten

INSERT VendasAnuais
( qtd	,	idVeiculo	,	idAnodaVenda	,	idMesdaVenda )
VALUES
( 101	,	112			,	31				,	15			),
( 102	,	112			,	31				,	18			),
( 103	,	112			,	31				,	21			),
( 104	,	113			,	31				,	24			),
( 105	,	113			,	31				,	27			),
( 106	,	113			,	31				,	30			),
( 107	,	114			,	31				,	33			),
( 108	,	114			,	31				,	36			),
( 109	,	114			,	31				,	39			),
( 110	,	115			,	31				,	42			),
( 111	,	115			,	31				,	45			),
( 112	,	115			,	31				,	48			),
( 113	,	116			,	31				,	15			),
( 114	,	116			,	31				,	18			),
( 115	,	116			,	31				,	21			),
( 116	,	117			,	31				,	24			),
( 117	,	117			,	31				,	27			),
( 118	,	117			,	31				,	30			)


-- 6. Alterar a fabricação dos veículos Zeo e Bjorn para o ano de 2026.
--    Os demais veículos alterar para 2030.
SELECT * FROM Veiculo
SELECT * FROM ANO


-- IDS MODELO:		10	Standard, 11	Premium	, 12	Executive
-- IDS FABRICANTE:	10	GM		, 11	Volks	, 12	Fiat
-- IDS ANO:			26	2025	, 27	2026	, 28	2027,		29	2028

INSERT Ano
VALUES
( 2030 ) -- ID: 32

SELECT	*
FROM	Veiculo
WHERE	idVeiculo IN ( 114 , 115 )

UPDATE	Veiculo
SET		idAnoFabricacao = 27
WHERE	idVeiculo IN ( 114 , 115 )

SELECT	*
FROM	Veiculo
WHERE	idVeiculo IN ( 112 , 113 , 116 , 117 )

UPDATE	Veiculo
SET		idAnoFabricacao = 32
WHERE	idVeiculo IN ( 112 , 113 , 116 , 117 )

-- 7. Alterar as Vendas dos Veículos:
-- Premium para janeiro de 2030

-- IDS MODELO:		10	Standard, 11	Premium	, 12	Executive
select * from Ano
select * from mes


SELECT	*
FROM	VendasAnuais
WHERE	idVeiculo IN (	SELECT	idVeiculo
						FROM	Veiculo 
						WHERE	idModelo = 11 )
UPDATE	VendasAnuais
SET		idAnodaVenda = 32,
		idMesdaVenda = 48
WHERE	idVeiculo IN (	SELECT	idVeiculo
						FROM	Veiculo 
						WHERE	idModelo = 11 )

INSERT Ano
VALUES
( 2031 ), -- ID: 33
( 2032 )  -- ID: 34

-- Standard para Dezembro de 2031
UPDATE	VendasAnuais
SET		idAnodaVenda = 33,
		idMesdaVenda = 15
WHERE	idVeiculo IN (	SELECT	idVeiculo
						FROM	Veiculo 
						WHERE	idModelo = 10 )


-- Executive para outubro de 2032
UPDATE	VendasAnuais
SET		idAnodaVenda = 34,
		idMesdaVenda = 21
WHERE	idVeiculo IN (	SELECT	idVeiculo
						FROM	Veiculo 
						WHERE	idModelo = 12 )


SELECT * FROM VendasAnuais

-- Parte 2: Banco de Dados PEDIDOS
-- 8. Deletar todos os REGISTROS da Tabela Itens de Pedido que sejam associados a produtos com a 
--    palavra CANETA em qualquer parte do campo Observação (Utilizar Subquery)
USE PEDIDOS

-- FORMA 01 DE RESPOSTA: UTILIZANDO A TABELA DE PRODUTO
SELECT	* 
FROM	TB_ITENSPEDIDO 
WHERE	ID_PRODUTO IN ( SELECT	ID_PRODUTO
						FROM	TB_PRODUTO 
						WHERE	DESCRICAO   LIKE '%CANETA%' )

DELETE
FROM	TB_ITENSPEDIDO 
WHERE	ID_PRODUTO IN ( SELECT	ID_PRODUTO
						FROM	TB_PRODUTO 
						WHERE	DESCRICAO   LIKE '%CANETA%' )


-- FORMA 01 DE RESPOSTA: UTILIZANDO A TABELA DE PEDIDO
SELECT	* 
FROM	TB_ITENSPEDIDO 
WHERE	NUM_PEDIDO IN ( SELECT	NUM_PEDIDO
						FROM	TB_PEDIDO  
						WHERE	OBSERVACOES LIKE '%CANETA%' )

DELETE
FROM	TB_ITENSPEDIDO 
WHERE	NUM_PEDIDO IN ( SELECT	NUM_PEDIDO
						FROM	TB_PEDIDO  
						WHERE	OBSERVACOES LIKE '%CANETA%' )

-- 9. Apagar todos os EMPREGADOS que possuam de 1 a 3 DEPENDENTES. 
--    Lembre-se de tratar a questão da Foreign Key.
-- PRIMEIRO, DELETAR DA TABELA FILHA (DEPENDENTE)
DELETE
FROM	TB_DEPENDENTE
WHERE	CODFUN IN ( SELECT CODFUN FROM TB_EMPREGADO WHERE NUM_DEPEND IN ( 1 , 2 , 3 ) )

-- NA SEQUENCIA, DELETAR DA TABELA MÃE (EMPREGADO)
DELETE
FROM	TB_EMPREGADO
WHERE	NUM_DEPEND IN ( 1 , 2 , 3 )

-- 10. Atualizar os salários dos EMPREGADOS que possuam Códigos de Supervisores ÍMPARES, 
--     aumentando em 12%. 
UPDATE	TB_EMPREGADO
SET		SALARIO = SALARIO * 1.12 -- | SALARIO = SALARIO * 0.12 + SALARIO | SALARIO = SALARIO * 12 / 100 + SALARIO
WHERE	COD_SUPERVISOR % 2 <> 0


--     E retirar 08% do Bonus Mensal dos empregados que possuam COD_CARGO e COD_DEPTO PARES.
UPDATE	TB_EMPREGADO
SET		PREMIO_MENSAL = PREMIO_MENSAL * 0.92 
WHERE	COD_CARGO % 2 = 0 AND COD_DEPTO % 2 = 0

-- CONSULTAS ENVOLVENDO MAIS DO QUE UMA TABELA (JUNÇÕES)

-- JUNÇÃO IMPLÍCITA: ELA JUNTA "N" TABELAS, DE FORMA HORIZONTAL E SEM UTILIZAR 
--                   EXPLICITAMENTE OS COMANDOS DE JUNÇÃO
SELECT TOP 1 * FROM TB_EMPREGADO
SELECT TOP 1 * FROM TB_CARGO 

SELECT	TB_EMPREGADO.NOME, 
		TB_EMPREGADO.SALARIO, 
		TB_CARGO.CARGO, 
		TB_EMPREGADO.COD_CARGO, 
		TB_CARGO.COD_CARGO
FROM	TB_EMPREGADO, TB_CARGO
WHERE	TB_EMPREGADO.COD_CARGO = TB_CARGO.COD_CARGO

-- APLICANDO O ALIAS AO NOME DAS TABELAS
SELECT		EMP.*, CRG.CARGO
FROM		TB_EMPREGADO	AS	EMP,
			TB_CARGO		AS	CRG
WHERE		EMP.COD_CARGO	=	CRG.COD_CARGO

-- EXERCÍCIO: RETORNAR DE FORMA IMPLÍCITA OS NOMES DE TODOS OS COLABORADORES + OS NOMES DOS DEPENDENTES
SELECT		EMP.NOME, DEP.NOME
FROM		TB_EMPREGADO	AS	EMP,
			TB_DEPENDENTE	AS	DEP
WHERE		EMP.CODFUN		=	DEP.CODFUN

SELECT TOP 1 * FROM TB_EMPREGADO
SELECT TOP 1 * FROM TB_DEPENDENTE

-- DE VEZ EM QUANDO, EU PRECISO FAZER O REFRESH DO MEU BANCO PEDIDOS

-- IMPORTAÇÃO DE BANCO DE DADOS PRONTO:				PEDIDOS (IMPACTA CERTIFICAÇÕES)
USE MASTER
DROP DATABASE PEDIDOS

-- 1º PASSO: SALVAR OS ARQUIVOS DO BANCO DE DADOS PEDIDOS (.MDF, .LDF, .NDF) EM UMA PASTA SEGURA

-- 2º PASSO: COPIAR OS ARQUIVOS DESTA PASTA PARA A PASTA DE DADOS DO SQL
-- MINHA MÁQUINA:
-- C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\DATA

-- 3º PASSO: IMPORTAR OS ARQUIVOS UTILIZANDO UM SQL WIZARD

-- CONHECENDO O COMANDO JOIN
-- INNER JOIN

-- TRANSFORMANDO ALGUMAS QUERIES FEITAS COM JUNÇÃO IMPLÍCITA, EM INNER JOIN
-- EMPREGADO + DEPENDENTE
-- SINTAXE: 
-- SELECT		(COLUMN_LIST)
-- FROM			TABLE_A
-- INNER JOIN	TABLE_B
-- ON			TABLE_A.KEY = TABLE_B.KEY

SELECT		EMP.CODFUN, EMP.NOME, DEP.NOME
FROM		TB_EMPREGADO	AS	EMP
INNER JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

SELECT * FROM TB_EMPREGADO
SELECT * FROM TB_DEPENDENTE

-- EXERCÍCIO: TRAZER TODOS OS EMPREGADOS COM SEUS RESPECTIVOS DEPARTAMENTOS
-- REALIZAR APENAS PARA FUNCIONÁRIOS DE SALÁRIO ACIMA DE 3000
SELECT		DPT.*, EMP.*
FROM		TB_DEPARTAMENTO		AS		DPT
INNER JOIN	TB_EMPREGADO		AS		EMP
ON			DPT.COD_DEPTO		=		EMP.COD_DEPTO
WHERE		EMP.SALARIO			>		3000          ---> LEMBRAR: WHERE VEM APÓS OS JOINS...

SELECT TOP 1 * FROM TB_EMPREGADO
SELECT TOP 1 * FROM TB_DEPARTAMENTO

-- EU POSSO INCLUIR DIVERSOS JOINS EM UMA MESMA ESTRUTURA...
-- EXEMPLO: VOU TRAZER OS DADOS DE CARGO, DEPARTAMENTO, EMPREGADO
SELECT		*
FROM		TB_EMPREGADO	AS	EMP

INNER JOIN	TB_DEPARTAMENTO	AS	DPT
ON			EMP.COD_DEPTO   =   DPT.COD_DEPTO

INNER JOIN	TB_CARGO		AS	CRG
ON			CRG.COD_CARGO	=	EMP.COD_CARGO

-- EXERCÍCIOS DE PRESENÇA
SELECT TOP 1 * FROM TB_PEDIDO
SELECT TOP 1 * FROM TB_ITENSPEDIDO
SELECT TOP 1 * FROM TB_PRODUTO

-- 1. LISTAR OS ITENS DO PEDIDO QUE POSSUAM PREÇO DE CUSTO DO PRODUTO, INFERIOR A 1 REAL
-- OBS.: TRAZER OS CAMPOS DE AMBAS AS TABELAS
SELECT		ITN.*, '-----------------------------' AS SEPARADOR, PRD.DESCRICAO, PRD.PRECO_CUSTO
FROM		TB_ITENSPEDIDO	AS	ITN
INNER JOIN	TB_PRODUTO		AS	PRD
ON			ITN.ID_PRODUTO	=	PRD.ID_PRODUTO
WHERE		PRD.PRECO_CUSTO <   1

-- 2. SELECIONAR TODOS OS PEDIDOS E SEUS RESPECTIVOS ITENS DE PEDIDO PARA A SITUAÇÃO 'E'
-- OBS.: TRAZER OS CAMPOS DE AMBAS AS TABELAS
SELECT		*
FROM		TB_PEDIDO		AS	PED
INNER JOIN	TB_ITENSPEDIDO	AS	ITN
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO
WHERE		PED.SITUACAO    =   'E'

-- 3. SELECIONAR TODOS OS PEDIDOS, QUE POSSUAM PRODUTOS DE QUANTIDADE REAL SUPERIOR A 3000 
--    FILTRAR TAMBÉM PARA OS PEDIDOS QUE POSSUAM ANO DA DATA DE EMISSÃO SUPERIOR A 2010
-- OBS.: TRAZER OS CAMPOS DE TODAS AS TABELAS
SELECT		PED.*, '-----------------------------', ITN.*, '------------------------', PRD.*
FROM		TB_PEDIDO		AS	PED

INNER JOIN	TB_ITENSPEDIDO	AS	ITN
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO

INNER JOIN	TB_PRODUTO		AS	PRD
ON			PRD.ID_PRODUTO  =   ITN.ID_PRODUTO
WHERE		PRD.QTD_REAL			>   3000
  AND       YEAR(PED.DATA_EMISSAO)	>	2010

-- LEFT JOIN: RETORNA TODOS OS REGISTROS DA TABELA A (ESQUERDA) E, PARA OS REGISTROS ONDE EXISTE MATCH/LINK
--            COM A TABELA B (DIREITA), RETORNA AS DEVIDAS INFORMAÇÕES
-- OBS.:      LATERALIZAÇÃO DO JOIN (À ESQUERDA)

-- NECESSIDADE: RETORNAR OS FUNCIONÁRIOS QUE POSSUEM DEPENDENTES COM OS RESPECTIVOS NOMES DE PAIS E FILHOS
SELECT		EMP.*, '-----------------------' AS SEPARADOR, DEP.*
FROM		TB_EMPREGADO	AS	EMP
INNER JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

SELECT * FROM TB_EMPREGADO
SELECT * FROM TB_DEPENDENTE WHERE CODFUN IN ( 7 , 8 )

-- NECESSIDADE: RETORNAR TODOS OS FUNCIONÁRIOS. PARA OS QUE POSSUIREM DEPENDENTES, EXIBIR OS NOMES.
SELECT		EMP.*, '-----------------------' AS SEPARADOR, DEP.*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

-- TRATAMENTO DE NULOS NO LEFT JOIN
SELECT		EMP.*, '-----------------------' AS SEPARADOR, DEP.*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN
WHERE		DEP.CODFUN IS NULL

-- SOMANDO A QUANTIDE DE REGISTROS DO LEFT JOIN COM OS NOMES DO INNER (SEM REPETIÇÃO)
SELECT		DISTINCT EMP.NOME
FROM		TB_EMPREGADO	AS	EMP
INNER JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

19 EMPREGADOS QUE POSSUEM DEPENDENTES
42 EMPREGADOS QUE NÃO POSSUEM DEPENDENTES

SELECT * FROM TB_EMPREGADO --> TOTAL DE REGISTROS DA TABELA: 19 + 42 = 61

-- EXERCICIO: SELECIONAR OS DEPARTAMENTOS ONDE NÃO EXISTE NENHUM FUNCIONÁRIO CADASTRADO
-- CONSTRUIR COM INNER, MUDAR PARA LEFT PARA ENTENDER, E SO DEPOIS DISSO, TRATAR O WHERE COM NULOS...
SELECT		DPT.*
FROM		TB_DEPARTAMENTO	AS	DPT
LEFT JOIN	TB_EMPREGADO	AS	EMP
ON			DPT.COD_DEPTO	=	EMP.COD_DEPTO
WHERE		EMP.COD_DEPTO IS NULL

-- NESTE CASO, EU TRARIA OS EMPREGADOS QUE NÃO POSSUEM DEPARTAMENTO ASSOCIADO (ERRO SOB A PERSPECTIVA DO PEDIDO)
SELECT		DPT.*, '----------------------', EMP.*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPARTAMENTO	AS	DPT
ON			DPT.COD_DEPTO	=	EMP.COD_DEPTO
WHERE		DPT.COD_DEPTO IS NULL

-- FUNÇÕES DE TRATAMENTO DE NULOS NO RETORNO DA INFORMAÇÃO
-- COALESCE(CAMPO, VALOR_SE_NULO)
-- ISNULL(CAMPO, VALOR_SE_NULO)
SELECT		DPT.*, '-----------------', 
			COALESCE(EMP.CODFUN, 9999) AS CODFUN, 
			ISNULL(NOME, 'SEM EMPREGADOS NESTE DEPARTAMENTO') AS NOME
FROM		TB_DEPARTAMENTO	AS	DPT
LEFT JOIN	TB_EMPREGADO	AS	EMP
ON			DPT.COD_DEPTO	=	EMP.COD_DEPTO

SELECT	*, 
		COALESCE(SINDICALIZADO,'SEM INFORMAÇÃO DE CADASTRO SINDICAL') AS SINDICALIZADO 
FROM	TB_EMPREGADO

-- RIGHT JOIN

-- NECESSIDADE: RETORNAR TODOS OS DEPENDENTES, POSSUINDO OU NÃO RELACIONAMENTO COM A TABELA DE EMPREGADOS
SELECT		EMP.*, '-----------------------', DEP.*
FROM		TB_EMPREGADO	AS	EMP
RIGHT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

-- EM UM SISTEMA DE CHAVE PRIMÁRIA E ESTRANGEIRA CORRETAMENTE CONFIGURADO, SUPONDO QUE A TABELA DA ESQUERDA
-- SEJA A TABELA MÃE E A TABELA DA DIREITA SEJA A TABELA FILHA, O INNER JOIN TERÁ O MESMO EFEITO QUE O RIGHT JOIN
SELECT * FROM TB_EMPREGADO	
SELECT * FROM TB_DEPENDENTE

INSERT TB_DEPENDENTE
( CODFUN , CODDEP , NOME , DATA_NASCIMENTO)
VALUES
( 99 , 1 , 'ISABELLA' , '2014-01-01' )

-- COMANDO ADICIONAL: SELECT INTO (CRIA UMA TABELA COM O RESULTADO DO SELECT ONDE ESTÁ INSERIDO)
-- OBS.: UM SELECT INTO NÃO REPLICA A ESTRUTURA DE CHAVES DAS TABELAS
-- SINTAXE: 
SELECT [COLUMN_LIST] 
INTO   <NOVA_TABELA>
FROM   <TABELA_ORIGEM>

SELECT	*
INTO	TB_EMPREGADO_V2
FROM	TB_EMPREGADO

SELECT	*
INTO	TB_DEPENDENTE_V2
FROM	TB_DEPENDENTE

INSERT TB_DEPENDENTE_V2
( CODFUN , CODDEP , NOME , DATA_NASCIMENTO)
VALUES
( 99 , 1 , 'ISABELLA' , '2014-01-01' )

SELECT		EMP.*, '-----------------------', DEP.*
FROM		TB_EMPREGADO_V2		AS	EMP
RIGHT JOIN	TB_DEPENDENTE_V2	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN


-- TRATAMENTO DE NULOS NO RIGHT JOIN
SELECT		EMP.*, '-----------------------', DEP.*
FROM		TB_EMPREGADO_V2		AS	EMP
RIGHT JOIN	TB_DEPENDENTE_V2	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN
WHERE		EMP.CODFUN IS NULL

-- NECESSIDADE: VERIFICAR TODOS OS PEDIDOS, QUE NÃO POSSUÍREM ITENS DE PEDIDO ASSOCIADOS
SELECT		PED.*, '-------------------', ITN.* 
FROM		TB_ITENSPEDIDO	AS	ITN
RIGHT JOIN	TB_PEDIDO		AS	PED
ON			ITN.NUM_PEDIDO  =   PED.NUM_PEDIDO

-- FULL OUTER JOIN
SELECT				EMP.*, '-----------------------', DEP.*
FROM				TB_EMPREGADO_V2		AS	EMP
FULL OUTER JOIN		TB_DEPENDENTE_V2	AS	DEP
ON					EMP.CODFUN		=	DEP.CODFUN

SELECT				EMP.*, '-----------------------', DEP.*
FROM				TB_DEPARTAMENTO		AS	DEP
FULL OUTER JOIN		TB_EMPREGADO		AS	EMP
ON					EMP.COD_DEPTO		=	DEP.COD_DEPTO

-- FULL OUTER JOIN COM TRATAMENTO DE NULOS
SELECT				EMP.*, '-----------------------', DEP.*
FROM				TB_EMPREGADO_V2		AS	EMP
FULL OUTER JOIN		TB_DEPENDENTE_V2	AS	DEP
ON					EMP.CODFUN		=	DEP.CODFUN
WHERE				EMP.CODFUN IS NULL
   OR				DEP.CODFUN IS NULL

SELECT				EMP.*, '-----------------------', DEP.*
FROM				TB_DEPARTAMENTO		AS	DEP
FULL OUTER JOIN		TB_EMPREGADO		AS	EMP
ON					EMP.COD_DEPTO		=	DEP.COD_DEPTO
WHERE				EMP.COD_DEPTO		IS NULL
   OR				DEP.COD_DEPTO		IS NULL

-- EXERCICIOS: CRIAR O CÓDIGO SQL QUE SOLUCIONE OS EXERCÍCIOS DOS SLIDES 27, 28 E 29
-- PRESENÇA: 1 AO 3
-- OPCIONAL: 4 AO 7
USE TSQL2012

SELECT		ORD.ORDERID		AS 'Número do Pedido', ORD.orderdate AS	'Data do Pedido', 
			CST.contactname AS 'Nome do Contato' , CST.country	 AS 'País'
FROM		SALES.Orders	AS	ORD
RIGHT JOIN	SALES.Customers	AS	CST
ON			ORD.custid		=	CST.custid

-- CORREÇÃO E DÚVIDAS DA AC04

-- * ---------------------------------------------------------------------------------------------------------------- * -- 
-- * AC04 -											LINGUAGEM SQL									- [[[JUNÇÕES]]]   * --
-- *																												  * --
-- * OBJETIVO DA ATIVIDADE: FIXAR OS CONTEÚDOS SOBRE JUNÇÕES, APLICANDO CONCEITOS UTILIZADOS EM SALA DE AULA          * --
-- * ---------------------------------------------------------------------------------------------------------------- * -- 
USE PEDIDOS
-- 01. BUSCAR OS NOMES DE EMPREGADOS, COM NOMES DE CARGOS, O SALARIO ATUAL E O SALARIO INICIAL 
-- E A DIFERENCA ENTRE O SALARIO ATUAL E O SALARIO INICIAL - SUBTRAIR UM DO OUTRO (VALOR: 1,5 PONTO)
SELECT		EMP.NOME, CRG.CARGO, EMP.SALARIO, CRG.SALARIO_INIC,
			EMP.SALARIO - CRG.SALARIO_INIC AS DIFERENCA_SALARIAL
FROM		TB_EMPREGADO	AS	EMP
INNER JOIN	TB_CARGO		AS	CRG
ON			EMP.COD_CARGO	=	CRG.COD_CARGO

-- 02. TRAZER O NOME DE TODOS OS COLABORADORES, INDEPENDENTEMENTE DE TEREM OU NÃO DEPENDENTES. 
-- PARA OS QUE TIVEREM DEPENDENTES, TRAZER O NOME DOS DEPENDENTES TAMBÉM, PARA OS QUE NÃO TIVEREM, 
-- TRATAR O CAMPO (NOME) COM A INFORMAÇÃO "NÃO POSSUI DEPENDENTES" (VALOR: 1,5 PONTO)
SELECT		EMP.NOME	AS NOME_FUN, 
			DEP.NOME	AS NOME_DEP_NTRATADO,
			COALESCE(DEP.NOME, 'NÃO POSSUI DEPENDENTES') AS NOME_DEP_V1,
			ISNULL(DEP.NOME, 'NÃO POSSUI DEPENDENTES') AS NOME_DEP_V2,
			DEP.CODFUN,
			COALESCE(DEP.CODFUN, 99999) AS COD_FUN_TRATADO
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN


-- 03. TRAZER O CÓDIGO DO EMPREGADO, O NOME DO EMPREGADO E O CÓDIGO E NOME DO SEU SUPERVISOR. 
-- PARA EMPREGADOS QUE NÃO POSSUÍREM SUPERVISOR, INFORMAR "NÃO FOI ENCONTRADO SUPERIOR" NO CAMPO NOME (VALOR: 1,5 PONTO)
SELECT		EMP1. CODFUN AS COD_FUN, EMP1.NOME AS NOME_FUN, EMP1.COD_SUPERVISOR ,
			EMP2. CODFUN AS COD_SUP, ISNULL(EMP2.NOME, 'NÃO POSSUI SUPERIOR') AS NOME_SUP
FROM		TB_EMPREGADO			AS	EMP1
LEFT JOIN	TB_EMPREGADO			AS	EMP2
ON			EMP1.COD_SUPERVISOR		=	EMP2.CODFUN

-- 04. 
-- A. LISTE OS CAMPOS NUM_PEDIDO, DATA_EMISSAO e VLR_TOTAL de PEDIDOS, SEGUIDOS DO NOME DO VENDEDOR
SELECT		PED.NUM_PEDIDO, PED.DATA_EMISSAO, PED.VLR_TOTAL, VEN.NOME
FROM		TB_PEDIDO	AS	PED
INNER JOIN	TB_VENDEDOR	AS	VEN
ON			PED.CODVEN	=	VEN.CODVEN


-- B. LISTE OS CAMPOS NUM_PEDIDO, DATA_EMISSAO e VLR_TOTAL de PEDIDOS, SEGUIDOS DO NOME DO CLIENTE
SELECT		PED.NUM_PEDIDO, PED.DATA_EMISSAO, PED.VLR_TOTAL, CLI.NOME
FROM		TB_PEDIDO	AS	PED
INNER JOIN	TB_CLIENTE	AS	CLI
ON			PED.CODCLI	=	CLI.CODCLI

-- C. UNIFIQUE AS DUAS CONSULTAS ANTERIORES, OU SEJA: LISTE OS CAMPOS NUM_PEDIDO, DATA_EMISSAO e VLR_TOTAL de PEDIDOS, 
--    SEGUIDOS DO NOME DO CLIENTE E DO NOME DO VENDEDOR (VALOR: 2,0 PONTOS)
SELECT		PED.NUM_PEDIDO, PED.DATA_EMISSAO, PED.VLR_TOTAL, VEN.NOME, CLI.NOME
FROM		TB_PEDIDO	AS	PED
INNER JOIN	TB_VENDEDOR	AS	VEN
ON			PED.CODVEN	=	VEN.CODVEN
INNER JOIN	TB_CLIENTE	AS	CLI
ON			PED.CODCLI	=	CLI.CODCLI

-- 05. SELECIONAR EM UMA MESMA CONSULTA, OS CARGOS EM QUE NÃO ESTÁ ALOCADO NENHUM FUNCIONÁRIO E OS FUNCIONÁRIOS QUE NÃO
-- ESTÃO ALOCADOS EM NENHUM CARGO (VALOR: 1,5 PONTO)

-- CONSULTA ABAIXO RESOLVE UMA PARTE DO PROBLEMA: CARGOS ONDE NÃO EXISTE EMPREGADO
SELECT		CRG.CARGO, EMP.NOME
FROM		TB_CARGO		AS	CRG
RIGHT JOIN	TB_EMPREGADO	AS	EMP
ON			CRG.COD_CARGO	=	EMP.COD_CARGO
WHERE		CRG.COD_CARGO IS NULL

-- UNIFICA AS DUAS VISÕES
UNION 

-- CONSULTA ABAIXO RESOLVE OUTRA PARTE DO PROBLEMA: EMPREGADOS QUE NÃO ESTÃO EM NENHUM CARGO
SELECT		CRG.CARGO, EMP.NOME
FROM		TB_CARGO		AS	CRG
LEFT JOIN	TB_EMPREGADO	AS	EMP
ON			CRG.COD_CARGO	=	EMP.COD_CARGO
WHERE		EMP.COD_CARGO IS NULL

-- RESTANDO A SOLUÇÃO CORRETA, ABAIXO (FULL OUTER JOIN)
SELECT				CRG.*, '-------------', EMP.*
FROM				TB_CARGO		AS	CRG
FULL JOIN			TB_EMPREGADO	AS	EMP
ON					CRG.COD_CARGO	=	EMP.COD_CARGO
WHERE				EMP.COD_CARGO IS NULL
   OR               CRG.COD_CARGO IS NULL

-- 06. SELECIONAR TODOS OS PEDIDOS (TABELA TB_PEDIDO) COM SEUS RESPECTIVOS ITENS DE PEDIDO E QUANTIDADES (TABELA TB_ITENSPEDIDO), 
-- BEM COMO O CÓDIGO E DESCRIÇÃO DOS PRODUTOS ASSOCIADOS (TB_PRODUTO)
-- FILTRAR APENAS POR PRODUTOS BRANCOS OU LARANJA (TABELA TB_COR) E COM DATA DE EMISSÃO (TABELA TB_PEDIDO) ENTRE 2012 E 2013 (VALOR: 2,0 PONTO)
SELECT TOP 1 * FROM TB_PEDIDO
SELECT TOP 1 * FROM TB_ITENSPEDIDO
SELECT TOP 1 * FROM TB_PRODUTO
SELECT TOP 1 * FROM TB_COR

SELECT		PED.NUM_PEDIDO, PED.DATA_EMISSAO,
			ITN.NUM_ITEM, ITN.QUANTIDADE, 
			PRD.DESCRICAO, 
			COR.COR
FROM		TB_PEDIDO		AS	PED
INNER JOIN	TB_ITENSPEDIDO	AS	ITN
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO
INNER JOIN	TB_PRODUTO		AS	PRD
ON			PRD.ID_PRODUTO	=	ITN.ID_PRODUTO
INNER JOIN	TB_COR			AS	COR
ON			COR.CODCOR		=	ITN.CODCOR
WHERE		( COR.COR = 'BRANCO' OR COR.COR = 'LARANJA' )
AND		    YEAR(PED.DATA_EMISSAO) BETWEEN 2012 AND 2013

-- * ---------------------------------------------------------------------------------------------------------------- * -- 
-- * AC04 -											LINGUAGEM SQL									- [[[JUNÇÕES]]]   * --
-- *																												  * --
-- *												ÓTIMA ATIVIDADE!!!											      * --
-- * ---------------------------------------------------------------------------------------------------------------- * -- 

-- AGREGAÇÕES E SUMARIZAÇÕES (AULA 01 DE 02)
SELECT * FROM TB_EMPREGADO

-- NECESSIDADE: SABER O TOTAL DE SALÁRIO GASTO EM TODA A EMPRESA... 
-- SUM(CAMPO): SUMARIZA A INFORMAÇÃO DE UM CAMPO, SOMANDO OS VALORES NUMÉRICOS/MONETÁRIOS
SELECT SUM(SALARIO) FROM TB_EMPREGADO

-- ... OU A MÉDIA SALARIAL...
-- AVG(CAMPO): MÉDIA ARITMÉTICA DE UM DETERMINADO CAMPO/CONJUNTO DE VALORES
SELECT AVG(SALARIO) FROM TB_EMPREGADO

-- OU A CONTAGEM DE SALÁRIOS...
-- COUNT(CAMPO/LINHA): CONTA A QUANTIDADE DE REGISTROS DE UMA DETERMINADA COLUNA OU DAS LINHAS DE UMA TAB
-- OBS.: NA CONTAGEM POR UMA COLUNA, ELE DESPREZARÁ OS NULOS
SELECT COUNT(SALARIO) FROM TB_EMPREGADO
SELECT COUNT(*) FROM TB_EMPREGADO

-- OU, POR ÚLTIMO, O MAIOR E O MENOR SALÁRIOS...
-- MAX/MIN(CAMPO): EXIBE O VALOR MÁXIMO OU MÍNIMO DE UM DETERMINADO CAMPO
SELECT MAX(SALARIO) FROM TB_EMPREGADO
SELECT MIN(SALARIO) FROM TB_EMPREGADO

-- A MINHA NECESSIDADE É DE AGRUPAR AS INFORMAÇÕES, UTILIZANDO OUTRO CAMPO COMO REFERÊNCIA
-- EXEMPLO: SABER O TOTAL INVESTIDO EM SALÁRIOS, POR DEPARTAMENTO
SELECT		SUM(SALARIO), COD_DEPTO
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO

-- EXERCÍCIO: DESCOBRIR QUANTOS ITENS DE PEDIDO EU TENHO POR NÚMERO DE PEDIDO
SELECT		COUNT(*) AS QTDE, NUM_PEDIDO
FROM		TB_ITENSPEDIDO
GROUP BY	NUM_PEDIDO
ORDER BY	QTDE DESC

-- PEDIDOS FUNCIONAIS! COMO MEU CLIENTE PEDIRIA A INFORMAÇÃO...

-- VERIFICAR QUAL O ANO EM QUE EU MAIS VENDI
-- OU... ELABORAR UMA TABELA COM O TOTAL DE VENDAS ($$$) POR ANO
SELECT		SUM(VLR_TOTAL) AS VALOR_VENDAS, YEAR(DATA_EMISSAO) AS ANO_VENDA
FROM		TB_PEDIDO
GROUP BY	YEAR(DATA_EMISSAO)
ORDER BY	VALOR_VENDAS DESC

-- AGRUPAMENTO UTILIZANDO MAIS DE UMA COLUNA
-- EXEMPLO: SOMAR O TOTAL DE PREMIO MENSAL POR CARGO E POR CONDIÇÃO SINDICAL
SELECT		SUM(PREMIO_MENSAL) AS TOTAL_PREMIO, COD_CARGO, SINDICALIZADO
FROM		TB_EMPREGADO
GROUP BY	COD_CARGO, SINDICALIZADO
ORDER BY	COD_CARGO

SELECT		COUNT_BIG(*) AS QTDE, COD_DEPTO 
INTO		TB_QTDEEMP_DEPTO
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO

SELECT * FROM TB_QTDEEMP_DEPTO
SP_HELP TB_QTDEEMP_DEPTO

DROP TABLE TB_QTDEEMP_DEPTO

-- INSERINDO A CLÁUSULA WHERE DENTRO DA SINTAXE DO GROUP BY
SELECT		[COLUMN_LIST] + SUM/AVG/COUNT/MIN/MAX
FROM		TABLE
WHERE		CONDITION
GROUP BY	[COLUMN_LIST]
ORDER BY	[COLUMN_LIST]



-- EXERCÍCIOS DE PRESENÇA
-- 1. DESCOBRIR A DATA DE NASCIMENTO DO FUNCIONÁRIO MAIS NOVO DA EMPRESA E A DATA DE ADMISSÃO
--    DO FUNCIONÁRIO MAIS VELHO DE EMPRESA (PRÓX. AULA: CONHECIMENTO ADICIONAL)
SELECT		MAX(DATA_NASCIMENTO) AS	DATA_MAIS_NOVO_IDADE,  MIN(DATA_ADMISSAO)	AS	DATA_MAIS_ANTIGO_EMPRESA
FROM		TB_EMPREGADO

-- RESPONDENDO A QUESTÃO UTILIZANDO O UNION...
SELECT		MAX(DATA_NASCIMENTO) AS	DATA_MAIS_NOVO_IDADE
FROM		TB_EMPREGADO
UNION
SELECT		MIN(DATA_ADMISSAO)	AS	DATA_MAIS_ANTIGO_EMPRESA
FROM		TB_EMPREGADO

-- TENTATIVA (ERRADA) DE RETORNAR O NOME DO FUNCIONÁRIO MAIS NOVO
SELECT		MAX(DATA_NASCIMENTO) AS	DATA_MAIS_NOVO_IDADE, NOME
FROM		TB_EMPREGADO
GROUP BY	NOME

-- PREPARANDO O RACIOCÍNIO PARA "PENSAR" COMO SUBQUERY...
SELECT		*
FROM		TB_EMPREGADO
WHERE		DATA_NASCIMENTO = '2006-21-02' -- MEU SQL: AAAA-DD-MM

-- TROCANDO POR UMA SUBQUERY...
SELECT		*
FROM		TB_EMPREGADO
WHERE		DATA_NASCIMENTO =	( 
									SELECT		MAX(DATA_NASCIMENTO)
									FROM		TB_EMPREGADO 
								)

INSERT TB_EMPREGADO
( NOME , DATA_NASCIMENTO )
VALUES
( 'ISABELLA PASSOS' , '2014-22-03' )

-- 2. VERIFICAR QUAL CODVEN MAIS VENDEU E QUAL FOI O MAIS EFICIENTE
--    EFICIENTE: VENDEU MAIOR VALOR COM MENOS VENDAS (PRÓX. AULA: COLOCAR NOME / JOIN)
SELECT		CODVEN, SUM(VLR_TOTAL) AS VALOR_TOTAL_VENDIDO
FROM		TB_PEDIDO
GROUP BY	CODVEN
ORDER BY	VALOR_TOTAL_VENDIDO

SELECT		CODVEN, 
			SUM(VLR_TOTAL)				AS	VALOR_TOTAL_VENDIDO,
			COUNT(*)					AS	QTDE_VENDAS,
			SUM(VLR_TOTAL) / COUNT(*)	AS	TICKET_MEDIO_V1,
			AVG(VLR_TOTAL)				AS	TICKET_MEDIO_V2
FROM		TB_PEDIDO
GROUP BY	CODVEN
ORDER BY	TICKET_MEDIO_V1 DESC

-- RESPOSTA 1: O CODVEN QUE MAIS VENDEU É O 3
-- RESPOSTA 2: O CODVEN MAIS EFICIENTE É O 8

-- PARA HOJE...
-- 1. CONSULTAS INCLUÍNDO JOIN + GROUP BY

-- EXERCÍCIO DESAFIO: INCLUIR O NOME DO VENDEDOR NO RETORNO DO SELECT ABAIXO
-- EX.: VERIFICAR QUAL CODVEN MAIS VENDEU
SELECT		SUM(PED.VLR_TOTAL) AS TOTAL_VENDAS, VEN.NOME
FROM		TB_PEDIDO		AS	PED
INNER JOIN	TB_VENDEDOR		AS	VEN
ON			PED.CODVEN		=	VEN.CODVEN
GROUP BY	VEN.NOME
ORDER BY	TOTAL_VENDAS

-- EX.: IDENTIFICAR A QUANTIDADE DE DEPENDENTES PARA CADA FUNCIONÁRIO
SELECT		EMP.NOME, COUNT(*) AS QTDE
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN
GROUP BY	EMP.NOME

-- EXERCÍCIO: SELECIONAR O TOTAL (SOMA) DE VENDAS (CADA VENDA: QUANTIDADE * PR_UNITARIO) POR PRODUTO
SELECT		SUM(ITN.QUANTIDADE * ITN.PR_UNITARIO) AS TOTAL_VENDIDO, PRD.DESCRICAO
FROM		TB_ITENSPEDIDO	AS	ITN
INNER JOIN	TB_PRODUTO		AS	PRD
ON			ITN.ID_PRODUTO	=	PRD.ID_PRODUTO
WHERE		PRD.DESCRICAO LIKE '%CANETA%'
GROUP BY	PRD.DESCRICAO
ORDER BY	TOTAL_VENDIDO

-- 2. FILTROS COM CLÁUSULA HAVING

-- LEMBRANDO DA SINTAXE DA CLÁUSULA WHERE NO GROUP BY E ADICIONANDO O COMANDO HAVING
SELECT		[COLUMN_LIST] + SUM/AVG/COUNT/MIN/MAX
FROM		TABLE
WHERE		CONDITION
GROUP BY	[COLUMN_LIST]
HAVING		GROUP_BY_CONDITION
ORDER BY	[COLUMN_LIST]

-- HAVING: INSERE UMA CONDIÇÃO, CONSIDERANDO UMA CLÁUSULA DE AGRUPAMENTO

-- EXEMPLO: EXIBIR A SOMA DE SALÁRIOS E A CONTAGEM DE PROFISSIONAIS, POR DEPARTAMENTO
--          APENAS PARA OS DEPARTAMENTOS QUE POSSUIREM MAIS DO QUE 5 PROFISSIONAIS
SELECT		SUM(SALARIO), COUNT(*) AS QTDE, COD_DEPTO
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO
HAVING		COUNT(*) > 5

SELECT * FROM TB_EMPREGADO
SELECT SUM(SALARIO) / COUNT(SALARIO) FROM TB_EMPREGADO
SELECT COUNT(*) FROM TB_EMPREGADO

-- 3. AC05 (GRUPO + ACOMPANHAMENTO DO PROFESSOR)

USE Concessionaria

-- 3. (AUXÍLIO...)
SELECT AVG(QTD) AS MENOR_VENDA FROM VendasAnuais

-- 6. (RESOLVIDO!)
SELECT		DISTINCT
			FAB.Nome		AS NOME_FABRICANTE,
			MIN(ANO.ANO)	AS ANO,
			VEI.descricao	AS DESCRIÇÃO_VEICULO,
			MODE.descricao	AS MODELO
FROM		VendasAnuais VED
INNER JOIN	Veiculo VEI		ON VED.idVeiculo = VEI.idVeiculo
INNER JOIN	MODELO MODE		ON MODE.idModelo = MODE.idModelo
INNER JOIN	Fabricante FAB	ON FAB.idFabricante = VEI.idFabricante
INNER JOIN	ANO ANO			ON VEI.idAnoFabricacao = ANO.idAno
GROUP BY	FAB.Nome, VEI.descricao, MODE.descricao
ORDER BY	FAB.Nome ASC, ANO DESC, VEI.descricao ASC, MODE.descricao DESC



-- PRÓXIMA SEMANA:
-- PROVA SEMESTRAL!!!